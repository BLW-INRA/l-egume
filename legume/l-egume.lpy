import sys
import os

try:
    import legume
    path_ = os.path.dirname(os.path.abspath(legume.__file__))#local absolute path of L-egume
except:
    path_ = r'C:\devel\l-egume\legume'#r'C:\devel\grassland'#r'H:\devel\grassland\grassland\luzerne' #r'C:\devel\grassland'#
path_leg = os.path.join(path_, 'input')#r'C:\devel\l-egume\l-egume\input'#r'C:\devel\grassland'#r'H:\devel\grassland\grassland\L-gume' #r'C:\devel\grassland'
path_out = os.path.join(path_, 'output')#r'C:\devel\grassland'#r'H:\devel\grassland\grassland\L-gume' #r'C:\devel\grassland'

sys.path.insert(0, path_)
sys.path.insert(0, path_leg)


#from rpy_options import set_options
#set_options(RHOME='c:/progra~1/R/R-2.12.1')
#from rpy import r
#import rpy2.rpy_classic as rpy
#rpy.set_default_mode(rpy.NO_CONVERSION)
#rpy.r.source(os.path.join(path_, 'dist_tetaf.r'))#'dist_tetaf.r') #r.source('C:/devel/grassland/dist_tetaf.r') #in L-egume folder
#rpy.r.source(os.path.join(path_, 'calc_root_tropism.r'))#r.source('C:/devel/grassland/calc_root_tropism.r') #in L-egume folder
#rpy.set_default_mode(rpy.BASIC_CONVERSION)
#r.source('dist_tetaf.r') #in L-gume folder
#r.source('calc_root_tropism.r') #in L-gume folder


from numpy.random import binomial, seed
from scipy import * 
from copy import deepcopy
import string
import time
from openalea.plantgl.all import *
import Obj3Dutils as o3d

try:
    from soil3ds import soil_moduleN as solN #import de la version develop si module soil3ds est installe
except:
    import soil_moduleN3 as solN #soil_moduleN2_bis as solN #! renommer car dans nouvelle version Lpy, mot module est reserve et fait planter!

try:
    from riri5 import RIRI5 as riri #import de la version develop si module soil3ds est installe
except:
    import RIRI5 as riri

import RootDistrib as rtd
import RootMorpho2 as rt
import ShootMorpho as sh
import daily_loop as loop 
import IOtable
import IOxls
import random



## lecture fichier meteo
#faire une fonction??
meteo_path = os.path.join(path_leg,'meteo_exemple.xls')#'meteo_exemple_debugL_gl.xls')#r'H:\devel\grassland\grassland\L-gume\meteo_exemple2.xls'
ongletM = 'Lusignan30'#'Lusignan302ans'#'DivLeg15'#'morpholeg15'#'combileg15'#'combileg16'#'Avignon30'#'exemple'#'morpholeg15'#'testJLD'#'competiluz'#
meteo = IOxls.read_met_file(meteo_path, ongletM)

## lecture fichier management
mn_path = os.path.join(path_leg,'management_exemple.xls')#'management_exemple3_debugL_gl.xls')#r'H:\devel\grassland\grassland\L-gume\management_exemple.xls'
ongletMn = 'Lusignan30IrrN2'#'Lusignan30IrrN2ans'#'DivLeg15'#'Lusignan30IrrN'#'illimite-sanscoupe'#'combileg15-irrigajusteeLUZTVMIN'#'combileg16-irrigajusteeMIN'#'Lusignan30'#'Avignon30IrrN'#'Avignon30'#
mng = IOxls.read_met_file(mn_path, ongletMn)

## lecture fichier initialisation
inis_path = os.path.join(path_leg, 'Init_sol_exemple.xls')#'Initialisation_sol_exemple.xls')
ongletIn = 'Lusignan30_5x5'#'Lusignan30'#'morpholeg_rhizo'#'combileg15'#'combileg16'#'Lusignan30Irr'#'Avignon30IrrN'#'Avignon30'#'
inis = IOxls.read_plant_param(inis_path, ongletIn)


## lecture fichier plante
path_plante = os.path.join(path_leg,'Parametres_plante_exemple.xls')#'Parametres_plante_v5cLucas.xls')#'Parametres_plante_v18.xls')#'Parametres_plante_v9Lucas_debugL.xls')#r'H:\devel\grassland\grassland\L-gume\Parametres_plante_v5cLucas.xls' 
ongletP = 'Fix2'#'giga'#'solnu'#'Fix1'#'Fix'#'timbale'#'formica'#'canto'##'alfalfa'#'geno_test'#'G3'#'C1'#'8_2'#'kayanne'#'leo'#'G1'#'timbale'##
ongletPvois = 'nonFixSimTest'#'giga'#'solnu'#'nonFix1'#'nonFix0'#'alfalfa'#'geno_test'#'G3'#

#lecture des parametres du sol
path_sol = os.path.join(path_leg,'Parametres_sol_exemple.xls')#'Parametres_sol_exemple2_debugL_glbis.xls')#
ongletS = 'lusignan99'#'morpholeg'#'combileg2015vshallow'#'combileg16vshallow'#'ASCHYD11'#
par_SN, par_sol = IOxls.read_sol_param(path_sol, ongletS)
par_SN['concrr'] = 0.#force eau de pluie / irrig a zero N, sinon apport 300 kg en irrigue!

#lecture scenario (si changement de parametres)
mn_sc = os.path.join(path_leg,'liste_scenarios_exemple.xls')#'liste_scenarios.xls')#(path_leg,'liste_scenarios.xls')
ongletScenar1 = 'Fix2'#'nonFixSimTest'#'default'#
ongletScenar2 = 'nonFixSimTest'#'nonFix1'#'default'

#lecture fichiers et variables de sortie
path_outf = os.path.join(path_leg,'mod_susm.xls')#
outf = IOxls.read_plant_param(path_outf, 'output_files')
outfvar = IOxls.read_plant_param(path_outf, 'daily_outputs')
#faudait lie ca plus simplement avec table pandas



#chemin des fichiers de sortie (doivent etre declares avant de lancer le L-system, pour pouvoir l'appeller en dehors de L-py)
outvarfile = 'toto.csv'#r'H:\devel\grassland\grassland\L-gume\toto.csv'
lsorgfile = 'lsAxes.csv'#r'H:\devel\grassland\grassland\L-gume\lsAxes.csv'
outimagefile = 'scene.bmp'#r'H:\devel\grassland\grassland\L-gume\scene.bmp'
outHRfile = 'outHR.csv'#r'H:\devel\grassland\grassland\L-gume\outHR.csv'
outBilanNfile = 'BilanN.csv'#r'H:\devel\grassland\grassland\L-gume\BilanN.csv'
resrootfile = 'newres.csv'#r'H:\devel\grassland\newres.csv'



#initialisation des variables globale de simulation
DOYdeb = 60#49#159#124#
DOYend = 180#335#610#120#250#244#282#
Rseed = 0#2#0 #random seed
deltalevmoy = 30 #degre.jours
deltalevsd = 15

nbcote = 8#1#10
optdamier = 4
typearrangement='damier8'#'homogeneous'
idscenar1 = -1 #inferieur a zero=defaut et fait rien
idscenar2 = 1#-1 #inferieur a zero=defaut et fait rien
opt_sky = 'V'#'VXpXmYpYm'

cote = 40.#100.#100#25.#25.#cm
dz_aerien = 2.#2.#2.5#5.#7.5#10.#7.#cm dz vise
Hmaxcouv = 150.#150.# 200. #cm
latitude = 46.43 #Lusignan (degre) -> a passer dans le fichier inis

obstarac_ = None#array([[-0.5]*5, [-0.5]*5, [-0.75]*5, [-1.]*5, [-1.]*5]).transpose() #matice 2D de valeurs de profondeur d'obstacle en m #None #



#1 residu = listes de 1 element
#DOYres = DOYdeb+20#300 #jour d'ajout des residus -> pas utilise
nb_res = 8

vAmount= [0.1]*nb_res#[20.]# T Fresh Weight.ha-1 (equivalent QRES)
vCNRESt = [40.]*4+[40.]*4 #g.g-1 (equivalent CsurNres)
#vCNRESt = [16.]*4+[40.]*4 #g.g-1 (equivalent CsurNres)
Vprop1 = [1./3., 1./3., 1./3.]+27*[0.] #distribution dans les horizons
vProps= [Vprop1]*nb_res#[Vprop1]#[Vprop1, Vprop1, Vprop1]
vWC=[0.7]*nb_res# fraction d'eau des residu frais (equivalent de Crespc /(%)/100)
vCC=[0.42]*nb_res# fraction de C des residus sec (equivalent de Crespc /(%)/100)
vNmires = [0.00197]*nb_res# fraction de poids frais residu en azote mineral (equivalent de Nminres(%)/100)



#options de simation
opt_residu = 1 #si 0, pas ativation de mineralisation
visu_root=1#1# pour visualisation/interpretation root
visu_shoot=1#1# pour visualisation/interpretation shoot
visu_sol=0#1# pour visualisation/interpretation sol
visu_solsurf=1#0 pour visualisation du pattern
frDisplay = 0 #1 #sauvegarde de la derniere vue
movDisplay = 0 # #sauvegarde toutes les vues pour faire un film




def init_glob_variables_sim(meteo, mng, DOYdeb, deltalevmoy, deltalevsd):
    
    ## meteo du jour
    DOY=DOYdeb
    meteo_j = IOxls.extract_dataframe(meteo, ['TmoyDay','I0','Et0','Precip','Tsol'], 'DOY', val=DOY)
    mng_j = IOxls.extract_dataframe(mng, ['Coupe','Irrig', 'FertNO3','FertNH4','Hcut'], 'DOY', val=DOY)
    for k in meteo_j.keys(): meteo_j[k]=meteo_j[k][0]
    for k in mng_j.keys(): mng_j[k]=mng_j[k][0]
    
    
    TT = 0
    TTsol = 0
    STEPS_ = meteo_j['TmoyDay']-5.#dTT(meteo_j['TmoyDay'], [ParamP[0]['Tdev']])# #variable remise  ajour chaque jour
    STEPSsol_ = meteo_j['Tsol']-5.
    ls_epsi = [0.]# [0.4, 0.4]##!! correspondance avec les nb de root systems!
    
    
    ##coupe
    TT_repousse = 0 #TT de la derniere coupev #resoud pb: TT utilise pour LAI pour NI revenait jamais a zero
    isTTcut = False
    #TTcutFreq = 18.*32#15.*32 #phyllochron
    isRegrowth = False #indicateur: est on a la pousse initiale ou bien plus tard?
    Hcut = 1.#3.#simple initialisation : est passe en lecture fichier management
    cutNB = 0
    
    ## divers
    start_time, past_time= time.time(), 0. #pour recuperer temps de calcul
    
    #distribution des retard a levee
    #deltalevmoy = 30 #degre.jours
    #deltalevsd = 15
    test_retard = []#pour gerer un decalage a la levee/reprise
    
    for i in range(138): test_retard.append(max(0,random.gauss(deltalevmoy,deltalevsd)))#test_retard.append(random.uniform(0,60))
    #for i in range(138): test_retard.append(0)#pas de retard.
    # a affectr a ['TT']!!
    
    return DOY, TT, TTsol, meteo_j, mng_j, STEPS_, STEPSsol_, ls_epsi, TT_repousse, isTTcut, isRegrowth, cutNB, Hcut, start_time, past_time, test_retard 



def init_ParamP(path_plante, ongletP, ongletPvois, nbcote, type='homogeneous', opt=4, ongletScenar1='default', ongletScenar2='default',idscenar1=1, idscenar2=1, mn_sc=None):
    
    #1) cree liste des paramtres plante (1dico par plante)
    #nbcote = nombre de plante sur un cote en supposant repartition homogene
    g4 = IOxls.read_plant_param(path_plante, ongletP)
    g4 = IOxls.modif_param(g4, ongletP, ongletScenar1, idscenar1, mn_sc=mn_sc)
    g5 = IOxls.read_plant_param(path_plante, ongletPvois)
    g5 = IOxls.modif_param(g5, ongletPvois, ongletScenar2, idscenar2, mn_sc=mn_sc)
    if type == 'homogeneous': #cas d'un couvert monospe homogene
        ParamP = [g4]*nbcote*nbcote
    elif type == 'damier8':#damier binaire 64 plantes
        ParamP = sh.damier8(g4,g5,opt=opt)
        if nbcote!=8:
            print('Warning! : damier8 option is for a 64 plant design')
    else:#defautl= force nb plante comme nbcote
        ParamP = [g4]*nbcote
        #ParamP = [g4]*10#*2#*30#[g6, g4, g6, g4, g6, g4, g6]#[g6,g4,g4,g4,g4,g4,g4,g4,g4,g4,g4,g4,g4]#[g4] 
        #[g1, g2, g3]#[g4, g5, g5, g5, g5, g5, g5] 
    
    
    #2) ajout de parametre 'recalcule'
    for nump in range(len(ParamP)):
      #update des parametre racinaire
      rt.update_root_params(ParamP[nump]) #'lsDrac', 'nb_ordre_rac', 'lsVrac', 'lsDemanDRac', 'LDs'
      #print 'LDs', ParamP[nump]['LDs2'], ParamP[nump]['LDs3'], ParamP[nump]['lsDrac'], ParamP[nump]['GDs2'], ParamP[nump]['GDs3']
      
      cor_lF = sqrt(ParamP[nump]['leafshape']/0.5) #pour afficher feuille avec surface reelle et corriger effet losange
      cor_lstp = sqrt(ParamP[nump]['stipshape']/0.5) #pour afficher feuille avec surface reelle et corriger effet losange
      
      ParamP[nump]['profilLeafI_l'] = []
      ParamP[nump]['profilLeafI_larg'] = []
      ParamP[nump]['profilNodeI_l'] = []
      ParamP[nump]['profilPetI_l'] = []
      ParamP[nump]['profilStipI_l'] = []
      ParamP[nump]['profilStipI_larg'] = []
      ParamP[nump]['profilPetI_l'] = []
      ParamP[nump]['profilLeafI_nfol'] = []
      ParamP[nump]['k_teta_distf'] = riri.disttetaf(abs(ParamP[nump]['gammaFeuil']), ParamP[nump]['gammaFeuilSD'])#proportion de feuille par        classe d'incli pour calcul des k_teta
      
      ParamP[nump]['profilRoot'] = rt.rootTropism(ParamP[nump]['IncRoot0'], ParamP[nump]['g_root'], segment=0.3, Long=300.)#rpy.r.rootTropism(ParamP[nump]['IncRoot0'], ParamP[nump]['g_root'], segment=0.3, Long=300.)#trajet d'une racine fille II
      
      for rank in range(1,51): #!limite a 50 noeuds!
          Norml_leaf = min(ParamP[nump]['profilLeafI_Rlen'][0]*rank+ParamP[nump]['profilLeafI_Rlen'][1], ParamP[nump]['profilLeafI_Rlen'][2]*rank+ParamP[nump]['profilLeafI_Rlen'][3])
          Normlarg_leaf = max(ParamP[nump]['profilLeafI_Rlarg'][0]*rank+ParamP[nump]['profilLeafI_Rlarg'][1], ParamP[nump]['profilLeafI_Rlarg'][2]*rank+ParamP[nump]['profilLeafI_Rlarg'][3])
          Norml_In = min(ParamP[nump]['profilNodeI'][0]*rank+ParamP[nump]['profilNodeI'][1], ParamP[nump]['profilNodeI'][2]*rank+ParamP[nump]['profilNodeI'][3])
          Norm_pet = min(ParamP[nump]['profilPetI'][0]*rank+ParamP[nump]['profilPetI'][1], ParamP[nump]['profilPetI'][2]*rank+ParamP[nump]['profilPetI'][3])
          Norml_Stp = min(ParamP[nump]['profilStpI_l'][0]*rank+ParamP[nump]['profilStpI_l'][1], ParamP[nump]['profilStpI_l'][2]*rank+ParamP[nump]['profilStpI_l'][3])
          Normlarg_Stp = min(ParamP[nump]['profilStpI_Rlarg'][0]*rank+ParamP[nump]['profilStpI_Rlarg'][1],ParamP[nump]['profilStpI_Rlarg'][2]*rank+ParamP[nump]['profilStpI_Rlarg'][3])
          Normnfol = min(ParamP[nump]['profilLeafI_Rnfol'][0]*rank+ParamP[nump]['profilLeafI_Rnfol'][1], 1.)#nfol est le maximum number of folioles
          
          ParamP[nump]['profilLeafI_l'].append(max(0.001,Norml_leaf*cor_lF*ParamP[nump]['Lfeuille']))
          ParamP[nump]['profilLeafI_larg'].append(max(0.001,Normlarg_leaf*Norml_leaf*cor_lF*ParamP[nump]['Lfeuille']))
          ParamP[nump]['profilNodeI_l'].append(max(0.001,Norml_In*ParamP[nump]['Len']))
          ParamP[nump]['profilPetI_l'].append(max(0.001,Norm_pet*ParamP[nump]['Lpet']))
          ParamP[nump]['profilStipI_l'].append(max(0.001,Norml_Stp*cor_lstp*ParamP[nump]['Lstip']))
          ParamP[nump]['profilStipI_larg'].append(max(0.001,Normlarg_Stp*Norml_Stp*cor_lstp*ParamP[nump]['Lstip']))
          ParamP[nump]['profilLeafI_nfol'].append(int(max(1,Normnfol*ParamP[nump]['nfol'])))#max 1 pour interdire les feuilles sans folioles.
    
    nbplantes = len(ParamP)
    return ParamP, nbplantes




def init_scene(ParamP, inis, cote, nbcote, dz_aerien, Hmaxcouv):
    #initialoise la scene: arrangement des plantes (carto), discretisation souterraine, discretisation aerienne
    # 1) CARTO
    distplantes = cote/nbcote#1. #cm
    
    ## pour ilot
    #carto = [array([0.,0.,0.]), array([distplantes,0.,0.]),array([-distplantes,0.,0.]),array([0.5*distplantes,0.866*distplantes,0.]),array([-0.5*distplantes,0.866*distplantes,0.]), array([0.5*distplantes,-0.866*distplantes,0.]), array([-0.5*distplantes,-0.866*distplantes,0.])]#, array([-10.,0.,0.]), array([0.,7.,0.])] #liste des localisations (1pt par plante) -> a lire en fichier #LF - cos (pi/3) = 0.5   sin (pi/3) = 0.866
    
    #carto = [array([0.,0.,0.]), array([distplantes,0.,0.]),array([-distplantes,0.,0.]),array([0.5*distplantes,0.866*distplantes,0.]),array([-0.5*distplantes,0.866*distplantes,0.]), array([0.5*distplantes,-0.866*distplantes,0.]), array([-0.5*distplantes,-0.866*distplantes,0.]),array([2*distplantes,0.,0.]),array([-2*distplantes,0.,0.]),array([2*0.5*distplantes,2*0.866*distplantes,0.]),array([-2*0.5*distplantes,2*0.866*distplantes,0.]), array([2*0.5*distplantes,-2*0.866*distplantes,0.]), array([-2*0.5*distplantes,-2*0.866*distplantes,0.])] #carto13
    
    ## pour champ en rangs 
    #yyy = [-15]*9+[0]*9+[15]*9
    #xxx = range(-20,25,5)*3
    #yyy = [-15]*9+[-7.5]*9+[0]*9+[7.5]*9+[15]*9+[22.49]*9
    #xxx = range(-20,25,5)*6
    #yyy = [-15]*5+[0]*5+[15]*5
    #xxx = range(-20,25,10)*3
    #yyy = [-15]*2+[0]*2+[15]*2
    #xxx = range(-20,25,25)*3
    #yyy = [-15]*1+[0]*1+[15]*1
    #xxx = range(-20,25,60)*3
    #yyy = [-15]*23+[-7.5]*23+[0]*23+[7.5]*23+[15]*23+[22.49]*23
    #xxx = range(-20,25,2)*6
    
    #pour grand rhizotron
    #yyy = [-12.25, 4.4, 21.05]
    #xxx = [-10.75, -8.35, -5.95, -3.55, -1.15, 1.25, 3.65, 6.05, 8.45, 10.85]
    
    
    #pour carre distance homogene
    yyy = [distplantes/2.]
    for i in range(1,nbcote):yyy.append(yyy[-1]+distplantes)
    xxx = yyy
    
    carto = []
    for i in range(len(xxx)): 
        for j in range(len(yyy)):
            carto.append(array([xxx[i],yyy[j],0.]))
    
    
    # 2) definition du pattern et discretisation sol
    pattern8 = [[0,0], [cote,cote]]
    #pattern8 =[[min(xxx)-dp,min(yyy)-dp], [max(xxx)+dp,max(yyy)+dp]]
    #[[-2.5,-2.5], [2.5,2.5]]#[[-5.,-5.],[5.,5.]]#[[-2.5,-2.5], [5,5]]#[[-12.5,-12.5],[12.5,12.5]]
    #pattern8 = [[-22.3/2.,-49.5/2.], [22.3/2.,49.5/2.]]#pattern.8 rhizotron equivalent (cm)
    
    Lsol = max((pattern8[1][0]-pattern8[0][0])/100., (pattern8[1][1]-pattern8[0][1])/100.)#m
    largsol = min((pattern8[1][0]-pattern8[0][0])/100., (pattern8[1][1]-pattern8[0][1])/100.)#m
    surfsolref = Lsol*largsol #m2
    dz_sol = inis['dz_sol']#4.#5. #cm
    ncouches_sol = int(inis['ncouches_sol'])#4#10#30
    prof_sol_max = ncouches_sol*dz_sol#80.
    
    discret_solXY = map(int, inis['discret_solXY'])#[10,10]# nb de discretisation du sol en X et en Y
    lims_sol = rtd.lims_soil(pattern8, dxyz=[[Lsol/discret_solXY[0]]*discret_solXY[0], [largsol/discret_solXY[1]]*discret_solXY[1], [dz_sol/100.]*ncouches_sol])
    
    
    #3) discretisation au niveau aerien
    #creation des grid3D pour calcul de rayonnement
    ls_gammagroup = map(int, riri.get_lsparami(ParamP, 'gammagroup'))
    setp = list(set(ls_gammagroup)) #set equivalent fonction r.unique!
    n_gamagroup = len(setp)
    
    for nump in range(len(ParamP)):#ajout a chaque plante de son id grille dans ParamP
        ParamP[nump]['id_grid'] = setp.index(int(ParamP[nump]['gammagroup']))  #pour savoir id de grille de la plante
    
    na, dxyz, lims_aer, origin_grid, surf_refVOX = riri.def_na_lims(pattern8, dz_aerien, Hmaxcouv,opt='3D')
    #na, dxyz, lims_aer, origin_grid, surf_refVOX = riri.def_na_lims(pattern8, dz_aerien, Hmaxcouv,opt='1D') #version 1D, comme avant
    m_lais = zeros([n_gamagroup, na[2], na[1], na[0]]) #ngamma, Z,Y,,X
    m_lais_construct = deepcopy(m_lais) #pour contsruction du m_lais a t+1
    triplets = riri.get_ls_triplets(m_lais[0], opt=opt_sky)#'VXpXmYpYm')#opt='V')#
    
    #liste des k_teta (coeff extinction directionnels) par entite
    ls_dif = [] 
    #prepa des k_teta par entite
    for i in setp:
        nump = ls_gammagroup.index(i) #retrouve numero de plante de premiere occurence de gammagroup
        ls_dif.append(ParamP[nump]['k_teta_distf'])
    
    res_trans, res_abs_i = [],[]
    res_rfr = []
    
    
    return carto, distplantes, pattern8, Lsol, largsol, surfsolref, dz_sol, ncouches_sol, prof_sol_max, discret_solXY, lims_sol, ls_gammagroup, setp, n_gamagroup, na, dxyz, lims_aer, origin_grid, surf_refVOX, m_lais, m_lais_construct, triplets, ls_dif, res_trans, res_abs_i, res_rfr
    #par logique, passer cote et nbcote dans ini?





def init_sol(inis, meteo_j, par_sol, par_SN, Lsol, discret_solXY, dz_sol,obstarac =None):
    
    #vecteurs d'initialisation du sol
    Tsol = meteo_j['Tsol']#15. #degresC
    num_nb = map(int, inis['num_nb'])#[6,6,18] #nbr de couche de chaque num de sol 
    vsoilnumbers = [1]*num_nb[0]+[2]*num_nb[1]+[3]*num_nb[2] #convention autorise 3 types d'horizon max
    #vDA = [par_SN['DA'][0]]*num_nb[0] + [par_SN['DA'][1]]*num_nb[1] + [par_SN['DA'][2]]*num_nb[2] #densite apparente de sol
    vCN = [par_SN['CN0_30']]*num_nb[0] + [par_SN['CN30_60']]*num_nb[1] + [par_SN['CN60_90']]*num_nb[2] #maxi 3 horizons
    vMO = [par_SN['MO0_30']]*num_nb[0] + [par_SN['MO30_60']]*num_nb[1] + [par_SN['MO60_90']]*num_nb[2] #maxi 3 horizons
    vARGIs = [par_SN['ARGIs0_30']]*num_nb[0] + [par_SN['ARGIs30_60']]*num_nb[1] + [par_SN['ARGIs60_90']]*num_nb[2]
    vCALCs = [par_SN['CALCs']]*ncouches_sol
    vNH4 = inis['NH4']#[2.]*ncouches_sol # #!! kg d'N.ha-1 (entree de STICS)
    vNO3 = inis['NO3']#[0.]*ncouches_sol
    HRpinit = inis['HRp']#[]
    if min(HRpinit)<0: #code -1 pour pas d'initialisation
        HRpinit = []
        
    vDA=[]
    for i in vsoilnumbers:
        vDA.append(par_sol[str(i)]['DA'])
        
    
    #vsoilnumbers = [1]+[2]*3+[3]*13+[4]*13 #numeros de sol du profil -> mesures acsyd11
    #vDA = [1.81]+[1.31]*3+[1.37]*13+[1.42]*13 #densite apparente de sol (mesure pesees initial aschyd11)
    #vCN = [par_SN['CN0_30']]*ncouches_sol #maxi 90cm en strates de 5cm
    #vMO = [par_SN['MO0_30']]*ncouches_sol #maxi 90cm en strates de 5cm
    #vARGIs = [par_SN['ARGIs']]*ncouches_sol #maxi 90cm
    #vCALCs = [par_SN['CALCs']]*ncouches_sol
    #vNH4 = [2.]*ncouches_sol # #!! kg d'N.ha-1 (entree de STICS)
    #coeff = 0.#0.09#coeff perte ressuyage -> a ajuster pour avoir environ 600 kg N.ha-1
    #vNO3 = [91.*coeff]*ncouches_sol # kg d'N.ha-1 (entree de STICS)
    #vNO3 = array([16.96, 16.07, 15.17, 33.92, 33.92, 33.92, 33.92, 62.49, 82.13, 89.27, 76.77, 107.13, 124.98, 142.84, 124.98, 142.84, 160.69, 151.76, 151.76, 142.84, 178.55, 133.91, 98.20, 89.27, 83.92, 89.27, 73.20, 89.27, 87.45, 62.49])*coeff #issu du profil en sol nu
    #HRpinit = [25.5,26.,25.,25.5,26.,26.,26.,26.5,26.5,27.,27.,27.,27.5,27.5,27.5,27.5,27.5,29,29,29,29,29,29,29,29,30,30,30,30,30]#-> mesures ahscyd au jour 195 (140711) -> init sol nu
    
    
    ## soil initialisation
    S = solN.SoilN(par_sol, par_SN, soil_number = vsoilnumbers, dxyz = [[Lsol/discret_solXY[0]]*discret_solXY[0], [largsol/discret_solXY[1]]*discret_solXY[1], [dz_sol/100.]*ncouches_sol], vDA=vDA, vCN=vCN,vMO=vMO, vARGIs = vARGIs,vNO3=vNO3,vNH4=vNH4, vCALCs=vCALCs, Tsol=Tsol,pH=par_SN['pH'], ZESX=par_SN['ZESX'] , CFES=par_SN['CFES'],obstarac=obstarac)
    
    
    if HRpinit!=[]:#initialise humidite si un vecteur est fourni
        S.init_asw(HRp_init=HRpinit) 
    
    
    #lims_sol = rtd.lims_soil(pattern8, dxyz=[[Lsol], [largsol], [dz_sol/100.]*ncouches_sol])
    
    if opt_residu==1:#initialisatio de residus
        S.init_residues(vCNRESt, vAmount, vProps, vWC, vCC)
    
    
    #print 'sol', sum(S.m_NO3), sum(S.m_NH4), sum(S.m_QH20fc)-sum(S.m_QH20wp)
    
    #Uval = 0.9*2.61#(epaisseur de sol* mm d'eau dans 1cm) #U quantite d'eau dans une couche superieure en mm (5 par default)
    Uval = par_SN['q0']*0.1*sum(S.m_QH20fc[0])*surfsolref / (S.dxyz[2][0]*100.)#(epaisseur de sol (cm)* mm d'eau dans 1cm) #U quantite d'eau dans une couche superieure en mm (5 par default)
    stateEV = [0.,0.,0.] #pour le calcul de l'evaporation du sol (memoire du cumul evapore depuis derniere PI)
    b_= solN.bEV(par_SN['ACLIMc'], par_SN['ARGIs'], HXs=0.261)#1.#valeur empirique tres proche#0.1#0.63#0.63
    #!!!
    
    return S, Tsol, Uval, stateEV, b_



def init_variables_plantes(ParamP, nbplantes):
    
    # 1) INVAR
    #dico des variables interne instantanes par plante  utilises dans differents calculs ou preparant des sorties
    
    ## SurfPlante: liste (par nump) de liste de surface de feuille verte au temps t 
    ## PARaPlante: liste (par nump) de liste de PARa feuille verte au temps t
    ## PARiPlante: liste (par nump) de liste de PARi feuille verte+senescente au temps t
    ## parap (anciens dpar / ls_parap): liste de delta de PARa du jour par plante (feuilles vertes) (utilise pour modulation racines notamment)
    ## parip: liste de delta de PARa du jour par plante (feuilles vertes+senescente)
    ## Hplante : liste de hauteur max des plantes
    ## Dplante: liste de diametre max des plantes
    ## Mrac_fine: Liste (par step/jour) de liste de delta de MSracines fines par plante
    ## Mpivot: Liste (par step/jour) de liste de delta de MSpivot par plante
    ## Maerien: Liste (par step/jour) de liste de delta de MSaerien par plante
    ## MS_rac_fine: liste des MSracines_fines cumule au temps t par plante
    ## MS_pivot: liste des MSpivot cumule au temps t par plante
    ## MS_aerien: liste des MSaerien cumule au temps t par plante
    ## MS_aer_cumul: liste des MSaerien cumule, SANS REMISE A ZERO A LA COUPE, pour calcul d'allocation aux racines.
    ## RLTot: liste de total fine root length par plante(m)
    ## Rdepth: liste de profondeur max du pivot par plante (cm)
    ## DiampivMax: liste de diametre max des pivot par plante
    ## countSh: Liste de nb tiges I cumule emis par plante depuis levee (tout A emis de B) - Compteur de Tige I
    ## countShExp: Liste de nb tiges I cumule emis par plante depuis levee par voie B->BDA - Compteur de bourgeons au niveau de la courrone  
    ## NBsh : Liste par plante de nb tiges (I ou II) avec nb phytomeres>50% du max
    ## NBI : Liste par plante de nombre de phytomere maxi sur tiges I ayant >75% du max
    ## NBD1 : Liste par plante de nombre de bourgeons dormants D()
    ## NBB : Liste par plante de nombre de bourgeons actifs B()
    ## NBBexp : Liste par plante de nombre de bourgeons actifs B() de statut exp = generateur de nouveaux axes
    ## lsA : Liste par plante de numero de nsh (B() et A()) actifs ou non
    ## lsAPrev : Liste par plante de numero de nsh (B() et A()) actifs ou non au step n-1 : utilise pour maintenir en dormance les D()
    ## lsApexMort : Liste par plante de numero de nsh (A()) mort
    ## DemandN_Feuil : Liste par plante de quantite d'N des feuille pour satisfaire 1 INN = 1 (g.plant-1)
    ## DemandN_Pet : Liste par plante de quantite d'N des petioles pour satisfaire 1 INN = 1 (g.plant-1)
    ## DemandN_Stem : Liste par plante de quantite d'N des tiges pour satisfaire 1 INN = 1 (g.plant-1)
    ## DemandN_Tot : Liste par plante de quantite d'N totales pour satisfaire 1 INN = 1 (g.plant-1)
    ## R_DemandC_Root : Liste par plante de ratio offre/demande C pour croissance des racines
    ## RLen1, Len2,RLen3,RLen4,RLentot : Liste par plante de longueur cumulee de racine d'ordre 1, 2, 3 et total (m)
    ## SRL: Liste par plante de specific root length (m.g-1)
    ## phmgPet: Liste par plante d'effet maximum d'allongement du a la photomorphogenese (petioles)
    ## phmgEntr: Liste par plante d'effet maximum d'allongement du a la photomorphogenese (entrenoeuds)
    ## phmgPet_m: Liste par plante d'effet maximum de reduction de croissance du a la photomorphogenese (petioles)
    ## phmgEntr_m: Liste par plante d'effet maximum de reduction de croissance du a la photomorphogenese (entrenoeuds)
    ## dMSenFeuil: Liste par plante des delta de biomasse de feuille senescent (g.plant-1)
    ## dMSenTige: Liste par plante des delta de biomasse de tige (entre-noeud et petiole) senescent (g.plant-1)
    ## R_DemandC_Shoot: Liste par plante de ratio offre/demande C pour croissance minimu des tiges
    ## NBphyto: Liste par plante de nbr de phytomeres compte sur la nase des entre-noeuds presents
    ## germinaltion: liste of a logical value: 0=no germination, 1=germination, 2=1feuille visible
    
    #! RLentot va remplacer RLTot!
    
    
    invar = {'SurfPlante':[], 'PARaPlante':[], 'PARiPlante':[], 'PARaPlanteU':[],'Hplante':[], 'Dplante':[], 'RLTot':[], 'RDepth':[], 'parap':[], 'parip':[], 'Mrac_fine':[], 'Mpivot':[], 'Maerien':[], 'Mfeuil':[],'Mcoty':[],'MS_rac_fine':[], 'MS_pivot':[], 'MS_aerien':[],'MS_feuil':[],'MS_aer_cumul':[], 'Mtot':[], 'MS_tot':[], 'DiampivMax':[], 'countSh':[], 'NBsh':[], 'NBI':[], 'DemandN_Feuil':[], 'DemandN_Pet':[], 'DemandN_Stem':[],'DemandN_Tot':[], 'DemandN_TotAer':[], 'NBD1':[], 'NBB':[], 'countShExp':[],'lsA':[],'lsAPrev':[],'lsApexMort':[], 'NBBexp':[], 'R_DemandC_Root':[],'RLen1':[], 'RLen2':[],'RLen3':[],'RLentot':[],'SRL':[],'phmgPet':[],'phmgEntr':[],'phmgPet_m':[],'phmgEntr_m':[],'firstleaf':[], 'Naerien':[], 'Npc_aer':[], 'Npc_piv':[], 'Npc_rac_fine':[],'Nuptake_sol':[],'NNI':[], 'Ndfa':[], 'Qfix':[], 'TT':[],'TTsol':[], 'dTT':[], 'dTTsol':[], 'dMSenFeuil':[],'dMSenTige':[], 'R_DemandC_Shoot':[],'RUEactu':[], 'DemCp':[],'DemCp_lf':[],'L_Sp':[],'remob':[],'Nrac_fine':[], 'Npivot':[],'dRLen2':[],'dRLen3':[],'dMSenRoot':[],'dRLenSentot':[], 'RLTotNet':[], 'MS_rac_fineNet':[],'perteN_rac_fine':[],'Surfcoty':[],'NBphyto':[],'germination':[],'MSgraine':[], 'Ngraine':[],'dMSgraine':[],'dNgraine':[], 'NBapexAct':[],'NreservPiv':[]} 
    
    for i in range(nbplantes): invar['SurfPlante'].append([]); invar['PARaPlante'].append([]); invar['PARiPlante'].append([]); invar['lsA'].append([]);invar['lsAPrev'].append([]);invar['lsApexMort'].append([])
    
    for i in range(nbplantes): invar['Hplante'].append(0.); invar['Dplante'].append(0.);invar['RLTot'].append(0.); invar['RDepth'].append(0.);invar['parap'].append(0.); invar['parip'].append(0.);invar['PARaPlanteU'].append(0.);invar['DiampivMax'].append(0.1); invar['countSh'].append(0);invar['NBsh'].append(0.);invar['NBI'].append(0.);invar['DemandN_Feuil'].append(0.);invar['DemandN_Pet'].append(0.);invar['DemandN_Stem'].append(0.);invar['DemandN_Tot'].append(0.);invar['NBD1'].append(0);invar['NBB'].append(0); invar['countShExp'].append(0);invar['NBBexp'].append(0); invar['R_DemandC_Root'].append(0);invar['RLen1'].append(0);invar['RLen2'].append(0);invar['RLen3'].append(0);invar['RLentot'].append(0);invar['SRL'].append(100.);invar['phmgPet'].append([1.]);invar['phmgEntr'].append([1.]);invar['phmgPet_m'].append([1.]);invar['phmgEntr_m'].append([1.]);invar['firstleaf'].append(float("inf"));invar['MS_aer_cumul'].append(0.); invar['NNI'].append(1.); invar['Ndfa'].append(1.); invar['TT'].append(0.);invar['TTsol'].append(0.);invar['dTT'].append(0.);invar['dTTsol'].append(0.);invar['dMSenFeuil'].append(0.);invar['dMSenTige'].append(0.);invar['R_DemandC_Shoot'].append(1.);invar['DemCp'].append(0.);invar['DemCp_lf'].append(0.);invar['MS_pivot'].append(0.);invar['remob'].append(0.);invar['RLTotNet'].append(0); invar['MS_rac_fineNet'].append(0);invar['perteN_rac_fine'].append(0);invar['NBphyto'].append(0);invar['germination'].append(0);invar['dMSgraine'].append(0.);invar['dNgraine'].append(0.);invar['NBapexAct'].append(0); invar['NreservPiv'].append(0)
    
    PG = array(riri.get_lsparami(ParamP, 'PMG'))/1000.
    invar['MSgraine'] = PG.tolist()
    invar['Mtot'].append(PG.tolist())
    invar['Ngraine'] = array(PG)*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.
    
    
    #invar['Maerien'].append(array(PG)*0.)
    #invar['Mpivot'].append(array(PG)*0.)
    #invar['Mfeuil'].append(array(PG)*0.)
    #invar['Mrac_fine'].append(array(PG)*0.)
    
    #initialisation avec des epsilon pour pas que ca bug?
    frac_coty_ini = array(riri.get_lsparami(ParamP, 'frac_coty_ini')) #0.5 ##a passer en parametre?
    PG = array(PG)*10e-15
    
    invar['Maerien'].append(array(PG)*frac_coty_ini) #4/5 va aerien
    invar['Mcoty'] = array(PG)*frac_coty_ini #dans les cotyledons
    invar['Mrac_fine'].append(array(PG)*(1.-frac_coty_ini)*array(riri.get_lsparami(ParamP, 'frac_rac_fine')))
    invar['Mpivot'].append(array(PG)*(1.-frac_coty_ini)*(1. - array(riri.get_lsparami(ParamP, 'frac_rac_fine'))))
    
    invar['Mfeuil'].append(array(PG)*frac_coty_ini) #tout aerien dans feuil
    invar['Naerien'] = array(PG)*frac_coty_ini*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.#meme teneur racine et shoot
    invar['Nrac_fine'] = array(PG)*(1.-frac_coty_ini)*array(riri.get_lsparami(ParamP, 'frac_rac_fine'))*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.#meme teneur racine et shoot
    invar['Npivot'] = array(PG)*(1.-frac_coty_ini)*(1. - array(riri.get_lsparami(ParamP, 'frac_rac_fine')))*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.#meme teneur racine et shoot
    #Mtige pas explicite pour le moment
    
    # 2) INVAR_SC: variables a autres echelle que plante (un dico par echelle des surface, surface verte, PARa cumules)
    ## 3 echelles: plante = 'plt', tige ramifiee ='sh', Axe = 'ax'
    ## Surf: 
    ## SurfVerte: 
    ## PARaF:
    ## MaxPiv: dictionnaire par cle d'axe de biomasse cumulee par pivot
    ## DiampivMax: dictionnaire par cle d'axe de diametre max de pivot
    ## AgePiv: dictionnaire par cle d'axe d'age des pivot en TT
    
    invar_sc = {'plt':{}, 'sh':{}, 'ax':{}}
    #reorganiser invar sur la base de ces 3 echelles??
    invar_sc['ax']['MaxPiv']={}
    invar_sc['ax']['DiampivMax']={}
    invar_sc['ax']['AgePiv']={}
    invar_sc['ax']['DemCRac']={}
    invar_sc['ax']['OfrCRac']={}
    invar_sc['ax']['QDCRac']={}
    invar_sc['ax']['QDCmoyRac']={} #QD moyen integre dans le temps par pivot
    invar_sc['ax']['StressHRac']={}
    invar_sc['ax']['PonderStressHRac']={}
    invar_sc['ax']['StressHmoyRac']={}#stress hydrique moyen des racines par pivot integre dans le temps
    invar_sc['ax']['NRac']={}#liste de nb d'apex par ordre pour chaque pivot
    invar_sc['ax']['dlRac']={}#delta de longueur des racines par ordre
    invar_sc['ax']['cumlRac']={}#cumul de longueur de racine par ordre
    
    #pour stocker NI max
    invar_sc['sh']['MaxNI']={}#dev max des axes primaires -> pour gerer vitesse de redemarrage des pivots
    
    #3) Autres variables globales utilisees ds calcul
    ## lsAxes: liste d'apex I(axes) actifs (utilise dans calcLeafStemRatio)
    ## lsApex: liste d'apex I et II actifs (utilise dans calcNB_NI et cumul_lenIN)
    ## lsApexStop : liste d'apex I et II a l'arret 
    ## lsApexAll : liste de tous les apex I et II
    ## lsOrgans: liste des organes (Lf/Stp/In/Pet) sur tous les axes (utilise dans cumul_lenIN, calcOffreC, calcDemandeC) (ancien lsActiveAxes)
    lsAxes = []
    lsApex = []
    lsApexStop = []
    lsApexAll = []
    lsOrgans =[['TT','organ','nump', 'nsh', 'rank', 'rankp', 'strate', 'surf', 'PARaF','statut','age','ordre','l','Long','DOY','cutNB', 'Larg']]
    savelsOrgans=[]
    #for i in range(nbplantes): lsOrgans.append([]) #faire une liste d'organe par plante??
    
    
    #4)#initialisation des ls_systrac (#pour recuperer les enveloppes de racine par plante)
    ls_systrac = {} 
    for i in range(nbplantes):ls_systrac[i]=[]
    
    #5) initialisation des indices de stress par plante a 1. (devrait passer dans invar)
    ls_ftswStress = {'WaterTreshExpSurf':[], 'WaterTreshDevII':[] ,'WaterTreshDevI':[], 'WaterTreshFix':[],'WaterTreshRUE':[]}
    ls_NNIStress = {'NTreshRUE':[], 'NTreshExpSurf':[], 'NTreshDev':[], 'NTreshDevII':[]}
    for i in range(nbplantes): ls_ftswStress['WaterTreshExpSurf'].append(1.);ls_ftswStress['WaterTreshDevII'].append(1.);ls_ftswStress['WaterTreshDevI'].append(1.);ls_ftswStress['WaterTreshFix'].append(1.);ls_ftswStress['WaterTreshRUE'].append(1.);ls_NNIStress['NTreshRUE'].append(1.);ls_NNIStress['NTreshExpSurf'].append(1.);ls_NNIStress['NTreshDev'].append(1.);ls_NNIStress['NTreshDevII'].append(1.)
    
    #6) Variables de profil plante (surface/eaclairement/N)
    
    LAIprofil, SurfprofilPlant = {}, []
    for i in range(0, na[2]):  LAIprofil[i]=0.#initialise variables globales de profils
    for i in range(nbplantes): SurfprofilPlant.append(deepcopy(LAIprofil))#liste de LAIprofil par plante
    
    deltaI_I0 = 0.05 #0.1 #delta entre classe d'aclairement relatif
    nbI_I0 = int(1./deltaI_I0) #nb classes d'eclairement relatif
    I_I0Classes = arange(deltaI_I0/2., 1.+deltaI_I0/2., deltaI_I0) #eclairememnt relatif moyen par classe
    I_I0profilLfPlant = [] #liste de surface de feuille par classe d'eclairement relatif
    for i in range(nbplantes): I_I0profilLfPlant.append(zeros(nbI_I0))
    I_I0profilPetPlant = deepcopy(I_I0profilLfPlant) #liste de longueur cumulee de petiole par classe d'eclairement relatif
    I_I0profilInPlant = deepcopy(I_I0profilLfPlant) #liste de longueur cumulee d'entre-noeuds par classe d'eclairement relatif
    
    NaClasses = ParamP[0]['Na0']*sh.Na_N0(I_I0Classes)#N0(INN=1.)*Na_N0(I_I0Classes)
    NlClasses = ParamP[0]['NL0Pet']*sh.Na_N0(I_I0Classes)
    NlinClasses = ParamP[0]['NL0Sh']*sh.Na_N0(I_I0Classes)
    # actuellement pas utilise -> serait a retirer proprement
    
    
    #variable de profil racine (a passer en dico?)
    res_root = [] 
    
    
    #RLProfil, RprospectProfil, rp0, rpp0 = [],[], {}, [] #liste de root length profil par horizon de sol; liste de profil des rayons de la racine primaire;rp0 et rpp0 sont les profils initiaux d'une plante, utilise pour faciliter l'instanciation de la liste de plantes
    #for i in range(0, ncouches_sol): rp0[i]=0.; rpp0.append(0.)
    #for i in range(nbplantes): RLProfil.append(deepcopy(rp0)); RprospectProfil.append(deepcopy(rpp0))
    
    
    return invar, invar_sc, lsAxes, lsApex, lsApexStop, lsApexAll, lsOrgans, savelsOrgans, ls_systrac, ls_ftswStress, ls_NNIStress, LAIprofil, SurfprofilPlant, deltaI_I0, nbI_I0, I_I0Classes, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NaClasses, NlClasses, NlinClasses, res_root




def init_outputs(ParamP, nbplantes):
    
    # 1) OUTVAR
    #dico de sorties
    outvar = {'colnames':[],'pattern':[],'TT':[],'TTsol':[], 'SurfPlante':[], 'PARaPlante':[], 'PARiPlante':[], 'epsi':[], 'Hplante':[], 'Dplante':[],'dMSaer':[],'RLTot':[], 'RDepth':[], 'MS_aerien':[],'MS_feuil':[],'MS_tot':[], 'countSh':[], 'demandC':[], 'Leaf_Stem':[], 'NBsh':[], 'NBI':[],'time':[],'FTSW':[],'Etransp':[], 'DemandN_Feuil':[], 'DemandN_Pet':[], 'DemandN_Stem':[],'DemandN_Tot':[], 'Npc':[], 'NBD1':[], 'NBB':[], 'countShExp':[], 'NBBexp':[], 'R_DemandC_Root':[], 'SRL':[],'phmgPet':[],'phmgEntr':[],'phmgPet_m':[],'phmgEntr_m':[], 'Naerien':[], 'Npc_aer':[], 'DemandN_Tot_Aer':[], 'Nuptake_sol':[], 'NNI':[], 'Ndfa':[], 'Qfix':[],'dMSenFeuil':[], 'dMSenTige':[],'MS_pivot':[],'MS_rac_fine':[],'R_DemandC_Shoot':[],'RUE':[],'BilanC_PARa':[], 'BilanC_RUE':[],'BilanCdMStot':[], 'BilanCdMrac_fine':[], 'BilanCdMpivot':[], 'BilanCdMaer':[],'BilanCdMSenFeuil':[],'BilanCdMSenTige':[], 'DemCp':[],'remob':[],'Npc_piv':[], 'Npc_rac_fine':[], 'dRLenSentot':[], 'dMSenRoot':[], 'RLTotNet':[], 'MS_rac_fineNet':[],'perteN_rac_fine':[],'NBphyto':[], 'cutNB':[],'NBapexAct':[]}
    outvar['pattern'].append(['pattern',0]+[surfsolref]*nbplantes)
    outvar['colnames'].append(['V1','steps']+riri.get_lsparami(ParamP, 'name')) #ajout des noms d'omglet en 1ere ligne
    
    # 2) Variables dynamique localisee du sol
    #id couches sorties sol (grand rhizotron)
    id_out = [0,1,4,11,17,25]# 5,10,25,60,90,130 cm, id de voxel dans le sol
    out_HR = [['DOY','HP5', 'HP10', 'HP25', 'HP60', 'HP90', 'HP130']]
    
    
    return outvar, id_out, out_HR






def Start():
    
    #initialisation des variables globale de simulation
    global DOY, TT, TTsol, meteo_j, mng_j, STEPS_, STEPSsol_, ls_epsi, TT_repousse, isTTcut, isRegrowth, cutNB, Hcut, start_time, past_time, test_retard, mn_sc
    
    ##seed nombre aleatoires
    global Rseed
    random.seed(Rseed)
    seed(Rseed)
    
    DOY, TT, TTsol, meteo_j, mng_j, STEPS_, STEPSsol_, ls_epsi, TT_repousse, isTTcut, isRegrowth, cutNB, Hcut, start_time, past_time, test_retard = init_glob_variables_sim(meteo, mng, DOYdeb, deltalevmoy, deltalevsd)
    
    # initialisation des parametres plante
    global ParamP, nbplantes
    global ongletP, ongletPvois, optdamier, typearrangement
    #ongletP = 'Fix1'#'Fix'#'timbale'#'formica'#'canto'#'giga'##'alfalfa'#'geno_test'#'G3'#'C1'#'8_2'#'kayanne'#'leo'#'G1'#'timbale'##
    #ongletPvois = 'nonFix2'#'nonFix0'#'alfalfa'#'geno_test'#'G3'#
    #optdamier = 4
    #typearrangement='damier8'    
    ParamP, nbplantes = init_ParamP(path_plante, ongletP, ongletPvois, nbcote, type=typearrangement, opt=optdamier, ongletScenar1=ongletScenar1, ongletScenar2=ongletScenar2,idscenar1=idscenar1, idscenar2=idscenar2, mn_sc=mn_sc)
    
    
    #initialisation de la scene
    global carto, distplantes, pattern8, Lsol, largsol, surfsolref, dz_sol, ncouches_sol, prof_sol_max, discret_solXY, lims_sol, ls_gammagroup, setp, n_gamagroup, na, dxyz, lims_aer, origin_grid, surf_refVOX, m_lais, m_lais_construct, triplets, ls_dif, res_trans, res_abs_i, res_rfr 
    
    carto, distplantes, pattern8, Lsol, largsol, surfsolref, dz_sol, ncouches_sol, prof_sol_max, discret_solXY, lims_sol, ls_gammagroup, setp, n_gamagroup, na, dxyz, lims_aer, origin_grid, surf_refVOX, m_lais, m_lais_construct, triplets, ls_dif, res_trans, res_abs_i, res_rfr = init_scene(ParamP, inis, cote, nbcote, dz_aerien, Hmaxcouv)
    
    #initialisation du sol
    global S, Tsol, Uval, stateEV, b_,  obstarac_, ls_mat_res, setr
    S, Tsol, Uval, stateEV, b_ = init_sol(inis, meteo_j, par_sol, par_SN, Lsol, discret_solXY, dz_sol,obstarac_)
    #mat_res = 0.*S.m_1 #en faire 
    ls_groupe_resid = map(int, riri.get_lsparami(ParamP, 'groupe_resid'))
    setr = list(set(ls_groupe_resid)) #set equivalent fonction r.unique!
    ls_mat_res = []
    for i in range(2):#len(setr)): #force a 2 sinon bug qd des esidu de l'esp 1 seulement
        ls_mat_res = ls_mat_res + [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]#ajout de 4 residus par groupe d'organ et groupe d'especes: feuille(0), tige(1), rac_fine(2), pivot(3)#  pour chaque groupe_resid 
    
    print len(ls_mat_res) #= [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]
    
    #initialisation des variables d'etat plante
    global invar, invar_sc, lsAxes, lsApex, lsApexStop, lsApexAll, lsOrgans, savelsOrgans, ls_systrac, ls_ftswStress, ls_NNIStress, LAIprofil, SurfprofilPlant, deltaI_I0, nbI_I0, I_I0Classes, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NaClasses, NlClasses, NlinClasses, res_root 
    
    invar, invar_sc, lsAxes, lsApex, lsApexStop, lsApexAll, lsOrgans, savelsOrgans, ls_systrac, ls_ftswStress, ls_NNIStress, LAIprofil, SurfprofilPlant, deltaI_I0, nbI_I0, I_I0Classes, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NaClasses, NlClasses, NlinClasses, res_root = init_variables_plantes(ParamP, nbplantes)
    
    #initialisation des sorties
    global outvar, id_out, out_HR
    outvar, id_out, out_HR = init_outputs(ParamP, nbplantes)
    
    #initialisation des variables d'echange avec exterieur pour couplages sol/rayonnement
    global tag_inputs_soil_step, res_soil_step, tag_inputs_residue_updt, res_residue_step, tag_light_inputs, local_res_trans, local_res_abs_i, tag_light_inputs2, local_res_rfr
    
    ##seed nombre aleatoires
    #global Rseed
    #random.seed(Rseed)
    #seed(Rseed)
    #ajout des profils de taille potentiel par rang dans ParamP (calcule 1 seul fois) (cm) / parametres de morpho racine par ordre
    
    # pour gerer sortie visuelle en batch - Lucas
    #frameDisplay(True)





def StartEach():
    global TT,TTsol, STEPS_, STEPSsol_, isTTcut, TT_repousse,  SurfprofilPlant, nbplantes, lsAxes, lsApex,lsApexAll, lsApexStop,lsOrgans, m_lais, res_trans, res_abs_i, res_rfr, m_lais_construct, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, invar, ls_systrac, Hcut, cutNB #utilise dz, I0, k (global pas mis a jour)#Hmaxcouv, LAIvois, PARt,
    
    global tag_light_inputs, local_res_trans, local_res_abs_i, tag_light_inputs2, local_res_rfr    
    
    #calcul TT
    STEPS_ = sh.dTT(meteo_j['TmoyDay'], [ParamP[0]['Tdev'], ParamP[0]['Tmin'], ParamP[0]['Tmax'], ParamP[0]['q']]) #prend valeur de nump=0 -> reference pour la simulation!
    TT = TT+STEPS_
    STEPSsol_ = sh.dTT(meteo_j['Tsol'], [ParamP[0]['Tdev'], ParamP[0]['Tmin'], ParamP[0]['Tmax'], ParamP[0]['q']])
    TTsol = TTsol + STEPSsol_
    
    for nump in range(nbplantes): 
        invar['dTT'][nump] = sh.dTT(meteo_j['TmoyDay'], [ParamP[nump]['Tdev'], ParamP[nump]['Tmin'], ParamP[nump]['Tmax'], ParamP[nump]['q']])
        invar['dTTsol'][nump] = sh.dTT(meteo_j['Tsol'], [ParamP[nump]['Tdev'], ParamP[nump]['Tmin'], ParamP[nump]['Tmax'], ParamP[nump]['q']])
        
        if invar['germination'][nump]>0:
            invar['TT'][nump] = invar['TT'][nump] + invar['dTT'][nump]
            invar['TTsol'][nump] = invar['TTsol'][nump] + invar['dTTsol'][nump]
    
    
    
    ############
    # step light transfer coupling
    ############
    
    #calcul profil surface couvert 
    mlaicot = sh.calc_surfcoty(invar['Mcoty'], invar['TT'], riri.get_lsparami(ParamP, 'DurGraine'), carto, ParamP, n_gamagroup, origin_grid, na, dxyz) #ajoute surface des cotyledons
    m_lais = deepcopy(m_lais_construct) + mlaicot
    
    
    #PAR / Blue voxel
    tag_light_inputs = [m_lais/surf_refVOX, triplets , ls_dif , meteo_j['I0']*surf_refVOX] #input tag
    local_res_trans, local_res_abs_i = riri.calc_extinc_allray_multi(*tag_light_inputs, optsky='soc')#(m_lais/surf_refVOX, triplets , ls_dif , meteo_j['I0']*surf_refVOX, optsky='soc')
    res_trans, res_abs_i = local_res_trans, local_res_abs_i #mise a jour variables globales
    
    #R_FR voxel (calcul de zeta)
    tag_light_inputs2 = [res_trans/(meteo_j['I0']*surf_refVOX)] #input tag
    local_res_rfr = riri.rfr_calc_relatif(*tag_light_inputs2)#(res_trans/(meteo_j['I0']*surf_refVOX))
    res_rfr = local_res_rfr #mise a jour variables globales
    
    
    
    
    #remise a zero m_lais_construct et LAIprofilplant pour nouvelle iteration  
    m_lais_construct = zeros([n_gamagroup, na[2], na[1], na[0]])
    
    LAIp  = {}
    for i in range(0, len(SurfprofilPlant[0].keys())): LAIp[i]=0.
    SurfprofilPlant = [] #liste de LAIprofil par plante
    for i in range(nbplantes): SurfprofilPlant.append(deepcopy(LAIp))
    I_I0profilLfPlant = []
    for i in range(nbplantes): I_I0profilLfPlant.append(zeros(nbI_I0))
    I_I0profilPetPlant = deepcopy(I_I0profilLfPlant)
    I_I0profilInPlant = deepcopy(I_I0profilLfPlant)
    
    #if TT%TTcutFreq <STEPS:
    if mng_j['Coupe']==1:
        Hcut = mng_j['Hcut']
        print 'cut ', Hcut
        isTTcut = True
        isRegrowth = True
        cutNB += 1
        TT_repousse = TT
        invar['Maerien'] = [array([1e-15]*nbplantes)] #mise a epsilon - discutable: biomasse residuelle peut ne pas etre negligeable! trefle..
        invar['Mfeuil'] = [array([1e-15]*nbplantes)] #tout l'aerien
        invar['Naerien'] = invar['Maerien'][0]*invar['Npc_aer']/100. #remet avec teneur en N conservee par rapport a avant la coupe
        #invar['Naerien'] = []
        #for nump in range(nbplantes): 
        #    #invar['MS_aerien'][nump] = 1e-15 
        #    invar['Naerien'][nump] = 1e-15*invar['Npc_bis'][nump]/100. #remet avec teneur en N conservee par rapport a avant la coupe
    else:
        isTTcut = False
    
    #calcul offre/demandeC sur la base des tableaux precedent avant leur remise a zero
    tab = IOtable.conv_dataframe(IOtable.t_list(lsOrgans))
    OffCp = sh.calcOffreC (ParamP, tab, 'plt')#pas utilise??!
    invar['DemCp'], invar['DemCp_lf'] = sh.calcDemandeC(ParamP, tab, 'plt',invar['dTT'], ls_ftswStress, ls_NNIStress)#attention, pour que calcul soit bon, faut le STEPS  suivant mis a jour!-> a faire en StartEach
    #invar['L_Sp'] = sh.calcLeafStemRatio(ParmP,tab, lsAxes)

    #sortie    
    lsAxes = []
    lsApex = []
    lsApexStop = []
    lsApexAll = []
    lsOrgans =[['TT','organ','nump', 'nsh', 'rank', 'rankp', 'strate', 'surf', 'PARaF','statut','age','ordre','l','Long','DOY','cutNB', 'Larg']]
    ls_systrac = {}
    
    invar['lsAPrev'] = invar['lsA']
    invar['SurfPlante'], invar['PARaPlante'], invar['PARiPlante'], invar['NBD1'],invar['NBB'],invar['lsA'],invar['NBBexp'],invar['dMSenFeuil'] ,invar['dMSenTige'],invar['NBphyto'],invar['NBapexAct'] = [], [], [],[],[],[],[],[],[],[],[]
    for i in range(nbplantes): invar['SurfPlante'].append([]); invar['PARaPlante'].append([]); invar['PARiPlante'].append([]);invar['NBD1'].append(0) ; invar['NBB'].append(0);invar['NBBexp'].append(0);invar['lsA'].append([]);ls_systrac[i]=[]; invar['phmgPet'].append([1.]);invar['dMSenFeuil'].append(0.);invar['dMSenTige'].append(0.);invar['NBphyto'].append(0.);invar['NBapexAct'].append(0)
    
    #ls_systrac[i]=[[carto[nump][0],carto[nump][1],0.,0.01,0.01]] #pour initialiser avec une racine et pas faire planter sol - pose pb seulement avant 1er step
    
    #initialisation des invar['PARiPlante'] avec ajout des PARi cotyledon:
    sh.calc_parapcoty(invar, m_lais, res_abs_i, invar['Mcoty'], invar['TT'], riri.get_lsparami(ParamP, 'DurGraine'), carto, ParamP, n_gamagroup, origin_grid, na, dxyz) 
    
    #sorties photomorphogenese
    for i in range(nbplantes): invar['phmgEntr'].append([1.]);invar['phmgPet_m'].append([1.]);invar['phmgEntr_m'].append([1.])
    
    invar_sc['ax']['StressHRac']={}
    invar_sc['ax']['PonderStressHRac']={}



def EndEach(lstring,lscene):
    
    
    global S, Uval, stateEV, DOY, meteo_j, mng_j, PP, res_root, nbplantes, surfsolref, ls_ftswStress, past_time, lsOrgans, ls_NNIStress, ls_mat_res
    global lsApex, lsApexAll, ls_systrac, lims_sol, b_, opt_residu, vCC, carto, start_time, cutNB, I_I0profilInPlant, deltaI_I0, nbI_I0, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NlClasses, NaClasses, NlinClasses
    global ParamP, par_SN, invar, invar_sc, outvar, res_trans
    global tag_inputs_soil_step, res_soil_step, tag_inputs_residue_updt, res_residue_step
    
    
    #################
    #  daily loop 
    #################
    #tag variables to facilitate outside coupling and data exchange with third party application
    # * unpacks the list of arguments
    
    #Potential plant growth
    invar, outvar, ls_epsi, ls_demandeN_bis, temps = loop.daily_growth_loop(ParamP, invar, outvar, res_trans, meteo_j, nbplantes, surfsolref, ls_ftswStress, ls_NNIStress, lsApex, lsApexAll)
    #step soil 
    tag_inputs_soil_step = [S, par_SN, lims_sol, surfsolref, stateEV, Uval, b_, meteo_j,  mng_j, ParamP, invar, ls_epsi, ls_systrac, ls_demandeN_bis, opt_residu] #input tag
    res_soil_step = loop.step_bilanWN_sol(*tag_inputs_soil_step)
    S, stateEV, ls_ftsw, ls_transp, ls_Act_Nuptake_plt, temps_sol = res_soil_step #unpacks results from a list and updates global variables
    #update stress variables
    invar, invar_sc, outvar, I_I0profilInPlant, ls_ftswStress, ls_NNIStress = loop.Update_stress_loop(ParamP, invar, invar_sc, temps, DOY, nbplantes, surfsolref, ls_epsi, ls_ftsw, ls_transp, ls_Act_Nuptake_plt, ls_demandeN_bis, ls_ftswStress, lsOrgans, lsApex, start_time, cutNB, deltaI_I0, nbI_I0, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NlClasses, NaClasses, NlinClasses, outvar)  
    #update soil residues
    tag_inputs_residue_updt = [ls_mat_res, vCC, S, carto, lims_sol, ParamP, invar, opt_residu] #input tag
    res_residue_step = loop.update_residue_mat(*tag_inputs_residue_updt)
    ls_mat_res, S = res_residue_step #unpacks results from a list and updates global variables
    
    #pourquoi ls_res_mat remis a zero juste apres????
    
    
    
    #################
    # fin des mises a jour variables (meteo...) pour step suivant
    #################
    
    DOY+=1
    meteo_j = IOxls.extract_dataframe(meteo, ['TmoyDay','I0','Et0','Precip','Tsol'], 'DOY', val=DOY)
    mng_j = IOxls.extract_dataframe(mng, ['Coupe','Irrig', 'FertNO3','FertNH4','Hcut'], 'DOY', val=DOY)
    print DOY
    for k in meteo_j.keys(): meteo_j[k]=meteo_j[k][0]
    for k in mng_j.keys(): mng_j[k]=mng_j[k][0]
    
    
    #archivage de lsOrgans
    savelsOrgans.append(lsOrgans)
    
    
    #print invar['germination'], invar['TT']
    #print invar_sc['sh']['Surf'], lsSurfSh
    #print invar['NBBexp'][nump], outvar['NBBexp'][-1][0][nump+2]
    #print invar['lsA']
    #print sum(I_I0profilLfPlant[0]*NaClasses), sum(I_I0profilLfPlant[0]), sum(I_I0profilLfPlant[0]*NaClasses)/sum(I_I0profilLfPlant[0])
    #print sum(I_I0profilPetPlant[0])
    
    #prints et log
    #print epsi, sum3(S.asw_t)  #epsi, map_PI, D,  sum3(ls_roots_eff[0]), sum3(m_frac_evap),sum3(m_frac_transpi),sum3(m_frac_evap)+sum3(m_frac_transpi), sum3(S.asw_t)#, S1#, #, ls_transp, ftsw_tevapo_tot#ftsw_t#
    #print invar_sc['ax']['MaxPARaF']
    #print 'mat_res', map(sum, ls_mat_res)
    #remise a zero de ls_mat_res
    #ls_mat_res = [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]#par groupe d'organe et groupe d'especes: feuille(0), tige(1), rac_fine(2), pivot(3)# + faire pour chaque groupe_resid (1 seul ici)
    ls_mat_res = []
    for i in range(2):#len(setr)): #force a 2 sinon bug qd des residus de l'esp 1 seulement
        ls_mat_res = ls_mat_res + [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]#ajout de 4 residus par groupe d'organ et groupe d'especes: feuille(0), tige(1), rac_fine(2), pivot(3)#  pour chaque groupe_resid 
    
    
    
    
    #################
    # pour gerer les vues pour 1 film - lucas (movDisplay == 1)
    #################
    
    outimagepathtemp = os.path.join(path_out, 'scene_'+str(DOY)+'.bmp')#r'H:\devel\grassland\grassland\L-gume\scene.bmp'
    if movDisplay == 1:
        ## fait pour simul depuis L-py reglee manuellement
        #frameDisplay(True)
        #Viewer.display(lscene)
        #Viewer.grids.setXYPlane(0)
        #Viewer.camera.setPosition((0,-150,20))
        #Viewer.camera.lookAt((0,-150,20),(20,20,-20))#((15,100,100),(0,0,0))
        Viewer.frameGL.setSize(600,500)
        Viewer.frameGL.saveImage(outimagepathtemp)
        #Viewer.stop()



def End(lstring,lscene):
    global res_root, outvarpath,outimagepath, savelsOrgans, lsOrgans
    
    #fermeture des bilans -> print cause pb: les sortir en fichier!
    #sys.stdout=open(outBilansTxt,'w')
    S.CloseWbalance(print_=0)
    S.CloseNbalance(print_=0)
    S.CloseCbalance(print_=0)
    #sys.stdout.close() #!! -> fait planter les print en re-run
    #en faire une fonction +  ecriture des disctionnaires en Rdata?  
    
    
    dicout= {}
    dicout['NRain'] = S.bilanN['cumRain']
    dicout['NIrrig'] = S.bilanN['cumIrrig']
    dicout['fertNO3'] = S.bilanN['cumfertNO3']
    dicout['fertNH4'] = S.bilanN['cumfertNH4']
    dicout['HumusNMin'] = S.bilanN['cumMinN']
    if opt_residu == 1:
        dicout['Res1'] = S.bilanN['cumNRes1']
        dicout['Res2'] = S.bilanN['cumNRes2']
        dicout['Res3'] = S.bilanN['cumNRes3']
        dicout['ResidueMinN'] = S.bilanN['cumNRes1']+S.bilanN['cumNRes2']+S.bilanN['cumNRes3']
        for i in range(len(S.bilanN['NminfromNres'])):
            dicout['NminfromNres'+str(i)] = S.bilanN['NminfromNres'][i] #ajout des sorties Nmin par residu
    
    dicout['Lix'] = S.bilanN['cumLix']
    #dicout['N2O'] = S.bilanN['cumN2O']
    dicout['UptPlt'] = map(sum, S.bilanN['cumUptakePlt']) 
    dicout['azomes'] = S.bilanN['azomes']
    #serait a formater dans module sol
    
    #y ajoute les elements du bilan de C plante - mais devrait sortir un fichier separe!
    dicout['PARa'] = outvar['BilanC_PARa']
    dicout['RUE'] = outvar['BilanC_RUE']
    dicout['dMStot'] = outvar['BilanCdMStot']
    dicout['dMSrac'] = outvar['BilanCdMrac_fine']
    dicout['dMSpiv'] = outvar['BilanCdMpivot']
    dicout['dMSaer'] = outvar['BilanCdMaer']
    dicout['dMSenFeuil'] = outvar['BilanCdMSenFeuil']
    dicout['dMSenTige'] = outvar['BilanCdMSenTige']
    
    if outf['outBilanNfile'] != 0.:
        IOtable.write_dict(dicout, path_out, outBilanNfile)
    
    
    #ecriture en sortie du profil racinaire
    if outf['resrootfile'] != 0.:
        resrootpath = os.path.join(path_out, resrootfile)#r'H:\devel\grassland\newres.csv'
        f = file (resrootpath, 'w')#r'H:\devel\grassland\newres.csv'
        IOtable.ecriture_csv(res_root, f)
        f.close()
    
    if outf['lsorgfile'] != 0.:
        lsorgpath = os.path.join(path_out, lsorgfile)#r'H:\devel\grassland\grassland\L-gume\lsAxes.csv'
        f = file (lsorgpath, 'w')
        IOtable.ecriture_csv_fromlist(savelsOrgans,  f)#savelsOrgans=liste des lsOrgans pour chaque iteration #lsOrgans #lsAxes #lsApex #lsApexStop #ls_systrac[0] 
        f.close()
    
    if outf['outvarfile'] != 0.:
        outvarpath = os.path.join(path_out, outvarfile)#r'H:\devel\grassland\grassland\L-gume\toto.csv'
        ls_keyvar_pot = ['colnames','pattern','TT','time','cutNB','SurfPlante', 'PARaPlante', 'PARiPlante', 'epsi', 'dMSaer', 'Hplante', 'Dplante','RLTot','RDepth','MS_aerien','MS_feuil','MS_tot','countSh','countShExp','demandC','Leaf_Stem','NBsh','NBI','NBD1','NBB','FTSW','Etransp','DemandN_Feuil','DemandN_Pet', 'DemandN_Stem','DemandN_Tot', 'DemandN_Tot_Aer', 'Npc', 'Npc_aer', 'NNI','Ndfa', 'Qfix','Naerien','Nuptake_sol','R_DemandC_Root', 'SRL','dMSenFeuil','dMSenTige', 'MS_pivot', 'MS_rac_fine','R_DemandC_Shoot','RUE','Npc_piv','Npc_rac_fine','dRLenSentot','dMSenRoot','RLTotNet','MS_rac_fineNet','perteN_rac_fine','NBphyto','NBapexAct']#,"phmgEntr","phmgEntr_m","phmgPet","phmgPet_m"]
        #valide cles active via fichier d'entree
        ls_keyvar = ['colnames']
        for i in range(1, len(ls_keyvar_pot)):
            k = ls_keyvar_pot[i]
            if outfvar[k] !=0.:
                ls_keyvar.append(k)
        
        #ecrit fichier avec variables selectionnees
        IOtable.write_dicttables(outvarpath, outvar, ls_keyvar)
    
    if outf['outHRfile'] != 0.:
        outHRpath = os.path.join(path_out, outHRfile)#r'H:\devel\grassland\grassland\L-gume\outHR.csv'
        f = file (outHRpath, 'w')
        #IOtable.ecriture_csv(out_HR, f)#ls_systrac[0]
        f.close()
    
    #pour gerer la vue de la sortie finale - lucas
    outimagepath = os.path.join(path_out, outimagefile)#r'H:\devel\grassland\grassland\L-gume\scene.bmp'
    if frDisplay == 1:
        frameDisplay(True)
        Viewer.display(lscene)
        Viewer.grids.setXYPlane(0)
        Viewer.camera.setPosition((0,-150,20))
        Viewer.camera.lookAt((0,-150,20),(20,20,-20))#((15,100,100),(0,0,0))
        Viewer.frameGL.setSize(600,850)
        Viewer.frameGL.saveImage(outimagepath)
        Viewer.stop()
    
    #frameDisplay(True)
    #Viewer.display(lscene)
    #Viewer.frameGL.saveImage(outimagepath)
    
    
    #IOtable.write_dict(invar_sc['ax']['PARaF'], r'H:\devel\grassland\grassland\L-gume', 'tot.csv')
    #print sum(m_lais), map(sum, invar['SurfPlante']) ->OK meme surface
    #print sh.cumul_lenIN(lsApex, IOtable.conv_dataframe(IOtable.t_list(lsOrgans)), I_I0profilInPlant)#lsApex
    #tab = IOtable.conv_dataframe(IOtable.t_list(lsOrgans))
    #print calcSurfScale(tab, 'sh')
    pass



module Sd(nump) # Seed
module A(nump, nsh, statut, age, duromb, rank, phyllotax) #primary shoot Apex
module A2(nump, nsh, statut, age, duromb, rank, rankp, phyllotax) #secondary shoot Apex (rankp= rang sur porteur)
module D(nump, nsh, statut, age, posi, parent) #Dormant bud of the crown
module D2(nump, nsh, age, rankp, phyllotax,shoottype) #dormant bud at the leaf axil
module B(nump, nsh, age, posi, nrhiz, azi, par, statut) #active Bud of the crown nsh=numero de tige; rhiz  nb noeud de rhizome
module SHP(nump, azi, elv0, posi, nbp,par) #SHoot Parameters: nbp et par pour moduler incli_ini en fonction de longueur et lumiere
module In(nump, nsh, age, rank, rankp, l, statut, ordre) #Internode (l longueur normalisee)
module Lf(nump, nsh, age, rank, rankp, l, tt_omb,statut, ordre) #Leaf (l longueur normalisee)
module Pet(nump, nsh, age, azi, l, statut) #Petiole
module Stp(nump, azi, l, statut)#Stipule
module RA(nump, nsh, age, rankp, agecum, moduloH) #primary Root Apex
module RB(nump, nsh, age, rankp, statut) #adventive root bud
module RS(nump, nsh, rankp, moduloH) #Root Segment
module RLB(nump, nsh, age, rankp, Horiz) #Root Lateral Bud
module RLAP(nump, nsh,age,rankp,l, Horiz) #Root Lateral Apex Prospection (max diameter reached by secondary roots)
module Coll(posi) #Collar 

module sol(S, nbcol) #objet sol entier (nbcol en y)
module solxy(S, idcol) #colone de sol pour visu 2D
module attente(n) #pour attendre initialisation des variables avant de representer le sol

Axiom: [attente(1)][Sd(0)][Sd(1)][Sd(2)][Sd(3)][Sd(4)][Sd(5)][Sd(6)][Sd(7)][Sd(8)][Sd(9)][Sd(10)][Sd(11)][Sd(12)][Sd(13)][Sd(14)][Sd(15)][Sd(16)][Sd(17)][Sd(18)][Sd(19)][Sd(20)][Sd(21)][Sd(22)][Sd(23)][Sd(24)][Sd(25)][Sd(26)][Sd(27)][Sd(28)][Sd(29)][Sd(30)][Sd(31)][Sd(32)][Sd(33)][Sd(34)][Sd(35)][Sd(36)][Sd(37)][Sd(38)][Sd(39)][Sd(40)][Sd(41)][Sd(42)][Sd(43)][Sd(44)][Sd(45)][Sd(46)][Sd(47)][Sd(48)][Sd(49)][Sd(50)][Sd(51)][Sd(52)][Sd(53)][Sd(54)][Sd(55)][Sd(56)][Sd(57)][Sd(58)][Sd(59)][Sd(60)][Sd(61)][Sd(62)][Sd(63)]#[Sd(64)][Sd(65)][Sd(66)][Sd(67)][Sd(68)][Sd(69)][Sd(70)][Sd(71)][Sd(72)][Sd(73)][Sd(74)][Sd(75)][Sd(76)][Sd(77)][Sd(78)][Sd(79)][Sd(80)][Sd(81)][Sd(82)][Sd(83)][Sd(84)][Sd(85)][Sd(86)][Sd(87)][Sd(88)][Sd(89)][Sd(90)][Sd(91)][Sd(92)][Sd(93)][Sd(94)][Sd(95)][Sd(96)][Sd(97)][Sd(98)][Sd(99)]#[Sd(100)][Sd(101)][Sd(102)][Sd(103)][Sd(104)][Sd(105)][Sd(106)][Sd(107)][Sd(108)][Sd(109)][Sd(110)][Sd(111)][Sd(112)][Sd(113)][Sd(114)][Sd(115)][Sd(116)][Sd(117)][Sd(118)][Sd(119)][Sd(120)][Sd(121)][Sd(122)][Sd(123)][Sd(124)][Sd(125)][Sd(126)][Sd(127)][Sd(128)][Sd(129)][Sd(130)][Sd(131)][Sd(132)][Sd(133)][Sd(134)][Sd(135)][Sd(136)][Sd(137)]

#Axiom: [pattern(0)sol(S)]plantation(nbplantes-1)


derivation length: DOYend-DOYdeb#200#98#224#73#93#66#93#66#149#119#179#300#365#(jours)
production:

#plantation(nbplt):
#    if nbplt>=0:
#    #for i in range(0, nbplt):
#        nproduce [Sd(nbplt)]plantation(nbplt-1)
#    else:
#        produce *


Sd(nump) :
    produce: Coll(carto[nump])RA(nump,0,-1,0,0,0)][SetHead()/(random.uniform(0.,360.))&(90)B(nump,0,ParamP[nump]['phyllochron'],carto[nump],0,random.uniform(0.,360.),0,'exp')] #ouverture de [ racine dans le Coll

B(nump, nsh, age, posi, nrhiz, azi, par, statut):
    global ls_ftswStress
    STEPS = invar['dTT'][nump]
    
    invar['NBB'][nump]+=1
    invar['lsA'][nump].append(nsh)
    if statut=='exp':
        invar['NBBexp'][nump]+=1
    
    vox = riri.WhichVoxel(carto[nump], origin_grid, na, dxyz)
    newpar = res_trans[-1][vox[1]][vox[0]]/surf_refVOX # A ameliorer :pris sur carto et position reelle des bourgeosn-> pb pour stolons?
    nbExp_Prev = outvar['NBBexp'][-1][0][nump+2]+1
    
    #control de la vitesse de tallage
    if nsh==0:#tige seminale -> pas d'attente
        deldeb = 0
    else:
        if nsh==1:#pousse initiale -> debut tallage
            deldeb= ParamP[nump]['debTallage'] * ParamP[nump]['phyllochron']
        #else:
        #    deldeb =  ParamP[nump]['phyllochron'] / ParamP[nump]['RvitTallage']
        elif statut=='exp':#bourgeon actifs produits sans dormance (tallage)
            deldeb =  ParamP[nump]['phyllochron'] * ParamP[nump]['RvitTallage']
        else: #bourgeons 'regular'
            deldeb = 0.
    
    #print 'B', nsh, age, deldeb
    
    if age >= deldeb/(0.00001+ls_ftswStress['WaterTreshDevI'][nump]*ls_NNIStress['NTreshDevII'][nump]) and newpar>=meteo_j['I0']*ParamP[nump]['par_tresh'] and nrhiz==0: #effet par_tresh marche mais a l'envers??? ->OK
        ##azi = random.uniform(0,360)
        elv0 = random.uniform(ParamP[nump]['elv0'][0],ParamP[nump]['elv0'][1])#(0,90)
        newageB = age%ParamP[nump]['phyllochron'] - test_retard[nump] 
        newageA = age%ParamP[nump]['phyllochron']+STEPS - test_retard[nump] 
        deltaBud = int(age/ParamP[nump]['phyllochron'])
        rpiv = invar['DiampivMax'][nump]/2.+ 0.5
        posini = array(carto[nump]) + array([random.uniform(-rpiv,rpiv),random.uniform(-rpiv,rpiv),0.])
        new_nrhiz = binomial(ParamP[nump]['DistLRhiz'][0], ParamP[nump]['DistLRhiz'][1])#2#5#0
        
        
        if statut=='exp' and invar['countShExp'][nump]< ParamP[nump]['nshoots']-1:#nsh< ParamP[nump]['nshoots'] and  : #modifie en nshoots-1, sinon la premiere tige n'est pas comptee!
            #print nump, 'B', newageA, test_retard[nump]
            newazi = random.uniform(0.,360.)
            invar['countSh'][nump] += 1
            newnsh = invar['countSh'][nump] #nsh+1
            invar['countShExp'][nump] += 1            
            invar['countSh'][nump] += 1
            newnsh2 = invar['countSh'][nump] #nsh+1
            
            if nsh==0 and invar['germination'][nump] == 0: #tige seminale, production du premier apex
                invar['germination'][nump] = 1
                sh.germinate(invar, ParamP[nump], nump)
            
            produce [@M(posi[0],posi[1],posi[2])SetHead()/(azi)&(90)B(nump,newnsh,newageB,posini,new_nrhiz,newazi,0,'exp')][D(nump,newnsh2,0,newageB,posini,nsh)]SHP(nump,azi,elv0,posi,0,newpar)GetPos(0,0,0)A(nump,nsh,1,newageA,0,0,azi)
        else:
            invar['countSh'][nump] += 1
            newnsh = invar['countSh'][nump] #nsh
            
            if nsh==0 and invar['germination'][nump] == 0: #tige seminale, production du premier apex
                invar['germination'][nump] = 1
                sh.germinate(invar, ParamP[nump], nump)
            
            produce [D(nump,newnsh,0,newageB,posini,nsh)]SHP(nump,azi,elv0,posi,0,newpar)GetPos(0,0,0)A(nump,nsh,1,newageA,0,deltaBud,azi)
    elif age >= ParamP[nump]['phyllochron']/(0.00001+ls_ftswStress['WaterTreshDevI'][nump]*ls_NNIStress['NTreshDevII'][nump]) and nrhiz>=1:
        newageB = age%ParamP[nump]['phyllochron']
        produce F(ParamP[nump]['LenRhiz'])B(nump,nsh,newageB, posi,  nrhiz-1, azi, newpar, statut)
    else:
        newageB = age+STEPS
        produce B(nump,nsh,newageB, posi, nrhiz, azi, newpar, statut)



GetPos(X0,Y0,Z0)A(nump,nsh,statut, age, duromb, rank, phyllotax):
    global ls_ftswStress, lsAxes, lsApex, lsApexStop, lsApexAll#, Hplante, Dplante
    STEPS = invar['dTT'][nump]
    
    idsh = str(nump)+'_'+str(nsh)
    idax = str(nump)+'_'+str(nsh)+'_'+str(0)
    
    invar['lsA'][nump].append(nsh)
    
    if Z0>invar['Hplante'][nump]:
        invar['Hplante'][nump] = Z0
    if Z0>Hcut and isTTcut==True:
        invar['Hplante'][nump]=Hcut
        invar['Dplante'][nump]=0.
        invar['lsA'][nump].remove(nsh)
    
    dX, dY = X0-carto[nump][0],Y0-carto[nump][1]
    dist2 =  dX*dX+dY*dY
    if dist2 > invar['Dplante'][nump]**2:
        invar['Dplante'][nump] = sqrt(dist2)
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARup = meteo_j['I0'] if vox[2] == 1 else res_trans[vox[2]-1][vox[1]][vox[0]] / surf_refVOX
    PARdown = res_trans[vox[2]][vox[1]][vox[0]] / surf_refVOX
    PARapex = PARup - (PARup-PARdown)*(Z0%dxyz[2]) / dxyz[2] #interpolation lineaire a l'iterieur du voxel
    I_I0 = PARapex/meteo_j['I0']
    
    ##invar_sc['ax']['MaxPARaF']
    
    try:
        PARlf = invar_sc['ax']['MaxPARaF'][idax]
    except:
        PARlf = 0.
    
    #print PARapex, PARlf
    PARsense = max(PARapex, PARlf) #niveau percu = mas d'apex ou feuille
    
    #print nump, age #malgre retard, tous les A ont le meme age
    if age >= ParamP[nump]['phyllochron']/(0.00001+ls_ftswStress['WaterTreshDevI'][nump]*ls_NNIStress['NTreshDev'][nump]): # introduit arret developpement des apex en fonction gradient vertical PAR
        if PARsense>=meteo_j['I0']*ParamP[nump]['par_tresh']:
            if nsh==0:
                invar['firstleaf'][nump]=min(TT,invar['firstleaf'][nump])
                if rank>=1: #tige seminale, production de la premiere feuille
                    invar['germination'][nump] = 2
            
            newage = age%ParamP[nump]['phyllochron']+STEPS
            liniF = sh.expansion(newage, ParamP[nump]['aF'], ParamP[nump]['delaiF'])
            liniP =  sh.expansion(newage, ParamP[nump]['aP'], ParamP[nump]['delaiP'])
            liniS = sh.expansion(newage, ParamP[nump]['aS'], ParamP[nump]['delaiS'])
            liniE = sh.expansion(newage, ParamP[nump]['aE'], ParamP[nump]['delaiE'])#ajout lucas: necessaire chez le TB! sinon, les entrenoeuds demarrent au milieu de leur croissance... Pour eviter ce genre de problemes et/ou des decalages bizarres, s'assurer a l'avenir que les delaiE, delaiF et delaiP soient normalises pour que le TT au point d'inflexion de la fct logistique soit a la moitie d'un phyllochrone.
            
            lsAxes.append([nump,nsh,rank])
            lsApex.append([nump,nsh, rank, 1, I_I0,duromb,''])
            lsApexAll.append([nump,nsh, rank, 1, I_I0,duromb,''])
            invar['NBapexAct'][nump]+=1
            
            #Lucas:
            #shoottype = 'primary' if nsh==0 and invar['countShExp'][nump]< ParamP[nump]['nshoots']-1 else 'branch' ###permet de desactiver le D2 si il fait "double emploi" avec un axe primaire... Sans compter la tige seminale!!! (d'ou le nshoots-2)
            ###limite a la tige seminale : if nsh==0
            # corrGL: baser sur distance au collet
            dist_collet = o3d.distance(p1=array(carto[nump]), p2=array([X0,Y0,Z0]))
            shoottype = 'primary' if nsh==0 and dist_collet< 3. else 'branch'
            
            #mise a jour du NI max            
            IOxls.append_dic(invar_sc['sh']['MaxNI'], idsh, rank+1)
            
            
            produce GetPos(X0,Y0,Z0)In(nump,nsh,newage,rank,0,liniE,'exp',1)[GetPos(X0,Y0,Z0)RB(nump, nsh,0,rank,0)][D2(nump,nsh,newage,rank,phyllotax,shoottype)][Stp(nump, phyllotax, liniS, 'exp')Pet(nump,nsh,newage, phyllotax,liniP,'exp')GetPos(X0,Y0,Z0)GetUp(0,0,0)Lf(nump,nsh,newage,rank,0,liniF,0.,'exp',1)]GetPos(X0,Y0,Z0)A(nump,nsh,1,newage, 0, rank+1, phyllotax+ParamP[nump]['phyllotaxy'])
        else:#ombre
            if rank>3:#si tige n'est plus bourgeon
                try:
                    if invar_sc['sh']['SurfVerte'][idsh]==0.:#si ombre et tige sans surface
                        test=1
                    else:
                        test=0
                except:
                    test=0
                
                if test==1:#invar_sc['sh']['SurfVerte'][idsh]==0.:#si ombre et tige sans surface #invar_sc['sh']['Surf']
                    invar['lsApexMort'][nump].append(nsh)
                    try:
                        invar['lsA'][nump].remove(nsh)
                    except:
                        print str(nsh), 'pas trouve dans lsA'
                    produce *
                else:#sinon pause/arret
                    lsApexStop.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                    lsApexAll.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                    produce GetPos(X0,Y0,Z0)A(nump,nsh,0,age, duromb+STEPS, rank, phyllotax)
            else:#sinon pause/arret 
                lsApexStop.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                lsApexAll.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                produce GetPos(X0,Y0,Z0)A(nump,nsh,0,age, duromb+STEPS, rank, phyllotax) #arret de developpement
            #lsApexStop.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
            #produce GetPos(X0,Y0,Z0)A(nump,nsh,0,age, duromb+STEPS, rank, phyllotax) #arret de developpement
    else: #pas atteint age de produire un phytomere
        lsAxes.append([nump,nsh,rank]) 
        lsApex.append([nump,nsh,rank,1, I_I0,duromb,''])
        lsApexAll.append([nump,nsh,rank,1, I_I0,duromb,''])
        invar['NBapexAct'][nump]+=1
        produce GetPos(X0,Y0,Z0)A(nump,nsh,statut,age+STEPS, duromb, rank, phyllotax)


GetPos(X0,Y0,Z0)A2(nump, nsh, statut, age, duromb, rank, rankp, phyllotax):
    global ls_ftswStress, lsApex, lsApexStop, lsApexAll
    STEPS = invar['dTT'][nump]
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARup = meteo_j['I0'] if vox[2] == 1 else res_trans[vox[2]-1][vox[1]][vox[0]] / surf_refVOX
    PARdown = res_trans[vox[2]][vox[1]][vox[0]] / surf_refVOX
    PARapex = PARup - (PARup-PARdown)*(Z0%dxyz[2]) / dxyz[2] #interpolation lineaire a l'iterieur du voxel
    I_I0 = PARapex/meteo_j['I0']
    
    if nsh in invar['lsApexMort'][nump]: #Meurt si tige porteuse meurt
        #print 'vrai', nsh
        produce *
    elif age >= ParamP[nump]['phyllochronII']/(0.00001+ls_ftswStress['WaterTreshDevII'][nump]*ls_NNIStress['NTreshDevII'][nump]): # introduit arret developpement des apex en fonction gradient vertical PAR
        if PARapex>=meteo_j['I0']*ParamP[nump]['par_tresh']:
            newage = age%ParamP[nump]['phyllochronII']+STEPS
            liniF = sh.expansion(newage, ParamP[nump]['aF'], ParamP[nump]['delaiF'])
            liniS = sh.expansion(newage, ParamP[nump]['aS'], ParamP[nump]['delaiS'])
            liniP = sh.expansion(newage, ParamP[nump]['aP'], ParamP[nump]['delaiP'])
            liniE = sh.expansion(newage, ParamP[nump]['aE'], ParamP[nump]['delaiE'])#ajout lucas: necessaire chez le TB! sinon, les entrenoeuds demarrent au milieu de leur croissance... 
            lsApex.append([nump,nsh,rank,2, I_I0,duromb, rankp])
            lsApexAll.append([nump,nsh,rank,2, I_I0,duromb, rankp])
            invar['NBapexAct'][nump]+=1
            
            produce GetPos(X0,Y0,Z0)In(nump,nsh,newage,rank,rankp,liniE,'exp',2)GetPos(X0,Y0,Z0)[Stp(nump, phyllotax, liniS, 'exp')Pet(nump,nsh,newage, phyllotax,liniP,'exp')GetPos(X0,Y0,Z0)GetUp(0,0,0)Lf(nump,nsh,newage,rank,rankp,liniF,0.,'exp',2)]GetPos(X0,Y0,Z0)A2(nump, nsh, 1,newage, 0, rank+1, rankp, phyllotax+ParamP[nump]['phyllotaxy'])
        else:
            if duromb<ParamP[nump]['MaxSurvOmbr']:
                lsApexStop.append([nump,nsh,rank,2, I_I0, duromb+STEPS,rankp])
                lsApexAll.append([nump,nsh,rank,2, I_I0, duromb+STEPS,rankp])
                produce GetPos(X0,Y0,Z0)A2(nump, nsh, 0,age, duromb+STEPS, rank, rankp, phyllotax) #arret de developpement du a ombre
            else:
                produce *
    elif PARapex<meteo_j['I0']*ParamP[nump]['par_tresh']:#ombre et hors production de nouveau phytomere
        if duromb<ParamP[nump]['MaxSurvOmbr']:
            lsApexStop.append([nump,nsh,rank,2, I_I0, duromb+STEPS,duromb,rankp])
            lsApexAll.append([nump,nsh,rank,2, I_I0, duromb+STEPS,duromb,rankp])
            produce GetPos(X0,Y0,Z0)A2(nump,nsh,0,age, duromb+STEPS, rank, rankp, phyllotax)
        else:#apex detruit au dela de MaxSurvOmbr
            produce * 
    else:#age avance car pas encore atteint de phyllochron   
        lsApex.append([nump,nsh,rank,2,I_I0,duromb,rankp])
        lsApexAll.append([nump,nsh,rank,2,I_I0,duromb,rankp])
        invar['NBapexAct'][nump]+=1
        
        produce GetPos(X0,Y0,Z0)A2(nump,nsh,statut,age+STEPS, 0, rank, rankp, phyllotax) 




SHP(nump,azi,elv0,posi,nbp,par):
     vox = riri.WhichVoxel(carto[nump], origin_grid, na, dxyz)
     newpar = res_trans[-1][vox[1]][vox[0]]/surf_refVOX
     produce SHP(nump,azi,elv0,posi, nbp+1, newpar)
#??erreur nbp (nb phytomere devrait dependre meme regle que phyllochrone! (bon seulement pour cet exemple)

GetPos(X0,Y0,Z0): #Rq: le GetPos doit etre dans les regle de production (pas interpretation pour que coupe soit effective)
    if Z0>Hcut and isTTcut == True:
        produce Cut()

GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump,nsh,age,rank,rankp,l,tt_omb,statut,ordre) :
    global  SurfprofilPlant, ls_ftswStress, lsOrgans, I_I0profilLfPlant #SurfPlante, PARaPlante, PARiPlante, Hplante, Dplante,
    STEPS = invar['dTT'][nump]
    
    
    dX, dY = X0-carto[nump][0],Y0-carto[nump][1]
    dist2 =  dX*dX+dY*dY
    if dist2 > invar['Dplante'][nump]**2:
        invar['Dplante'][nump] = sqrt(dist2)
    
    
    surF = sh.calc_surF(ParamP[nump], rank, rankp, ordre, l) #m2
    
    #gestion feuilles multiples: construction du ls_pts
    rk = rank+rankp if ordre==2 else rank
    rk = min(rk, len(ParamP[nump]['profilLeafI_l'])-1) #au cas ou profil pas assez long
    nf = ParamP[nump]['profilLeafI_nfol'][rk]
    ls_pts = []
    if nf > 3 or surF >= 0.001:#10cm2
        cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
        Long  = ParamP[nump]['profilLeafI_l'][rk]*l*cor_ordre
        Larg = ParamP[nump]['profilLeafI_larg'][rk]*l*cor_ordre
        ls_pts.append( o3d.leg_leaf_lucas(Long, Larg, gamma=ParamP[nump]['gammaFeuil'], nfol=nf, anginit=ParamP[nump]['IncPet'], geom=False))
        p1, lvec, rrec, r_azi, inclivec = o3d.conv_cyl(array([0.,0.,0.]), array([V1,V2,V3]), 1.)
        for i in range(len(ls_pts[0])):
            #r_azi = (rank*ParamP[nump]['phyllotaxy'])/180.*3.14#radians + ajouter l'azi random de l'axe?
            pt = o3d.RotateAxis (ls_pts[0][i], r_azi, 0)#rotation a faire
            ls_pts[0][i] = pt + array([X0,Y0,Z0]) #translation
    
    #Hmax
    if nf > 3 or surF >= 0.001:#10cm2
        for i in range(len(ls_pts)):
            if ls_pts[0][i][2]>invar['Hplante'][nump]:
                invar['Hplante'][nump] = ls_pts[0][i][2]
    else:
        if Z0>invar['Hplante'][nump]:
            invar['Hplante'][nump] = Z0
    
    if Z0>Hcut and isTTcut==True:
        invar['Hplante'][nump]=Hcut
    
    
    #sen participe a surface et LAI (interception) mais pas au PARa (absorption)
    if age> ParamP[nump]['spanMrt'] or tt_omb> ParamP[nump]['ombF_Ttresh']+ParamP[nump]['spanMrt']-ParamP[nump]['spanSen'] :
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        mfeuilmorte = surF*10000/ParamP[nump]['SLAmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4][voxsol[2]][voxsol[1]][voxsol[0]] += mfeuilmorte
        invar['dMSenFeuil'][nump] += mfeuilmorte
        produce *
    else:
        newage = age+STEPS
        
        #calcul des PARif, PARaf et complete
        if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee
            ls_vox, ls_strate, ls_PARif, ls_PARaF = [], [], [], []
            surf_elementaire = surF / float(len(ls_pts[0]))
            for i in range(len(ls_pts[0])):
                #print ls_pts[i], array([X0,Y0,Z0])
                vox = riri.WhichVoxel(ls_pts[0][i], origin_grid, na, dxyz)
                ls_vox.append(vox)
                ls_strate.append(vox[2])
                ls_PARif.append(res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX )
                
                # -> y a des nan iexpliques?? -> pas de surface ds ce voxel au coup d'avant? -> feuille a change de vosel?? (
                sVOX = m_lais[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]]#surface folaire dans le voxel
                if sVOX>0.:
                    ls_PARaF.append(res_abs_i[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] * surf_elementaire/sVOX *3600.*24/1000000.)
                else: #feuille dans voxel sans surface?
                    ls_PARaF.append( res_trans[vox[2]][vox[1]][vox[0]] * surf_elementaire * 3600.*24/1000000.)
            
            PARif = max(ls_PARif)#min ou moy?
            strate = max(ls_strate)#?? pas correct
            PARaF = sum(ls_PARaF)
        else:
            vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
            strate = vox[2] #starte z
            PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise 
            
            # -> y a des nan iexpliques?? -> pas de surface ds ce voxel au coup d'avant? -> feuille a change de vosel?? (elongation noeud?)
            sVOX = m_lais[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]]#surface folaire dans le voxel
            if sVOX>0.:
                PARaF = res_abs_i[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] * surF/sVOX *3600.*24/1000000.
            else: #feuille dans voxel sans surface?
                PARaF = res_trans[vox[2]][vox[1]][vox[0]] * surF * 3600.*24/1000000.
        
        
        I_I0 = PARif/meteo_j['I0']
        classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.
        
        
        ###ajout dans ls_organs et profil I_I0: 1 seule feuille (tient pas compte des feuilles multiples)
        ranklong = rank+rankp if ordre==2 else rank
        ranklong = min(ranklong, len(ParamP[nump]['profilLeafI_l'])-1)#au cas ou profil trop long
        cor_ordre=ParamP[nump]['ratioII'] if ordre==2 else 1.
        Longueur = ParamP[nump]['profilLeafI_l'][ranklong]*l*cor_ordre
        Largeur = ParamP[nump]['profilLeafI_larg'][ranklong]*l*cor_ordre
        
        lsOrgans.append([TT,'Lf',nump,nsh,rank,rankp,strate,surF,PARaF,statut,newage,ordre,l,Longueur,DOY,cutNB,Largeur]) #decalage de un step pour l en exp
        invar['SurfPlante'][nump].append(surF)
        I_I0profilLfPlant[nump][classI_I0] += surF
        
        
        #profil vertical de surface
        if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee
            surf_elementaire = surF / float(len(ls_pts[0]))
            for i in range(len(ls_pts[0])):
                strate = ls_strate[i]
                SurfprofilPlant[nump][strate] += surf_elementaire
        else:
            SurfprofilPlant[nump][strate] += surF
        
        
        if age> ParamP[nump]['spanSen'] : 
            if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee 
                surf_elementaire = surF / float(len(ls_pts[0]))
                for i in range(len(ls_pts[0])):
                    vox = ls_vox[i]
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
            else:
                m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF 
            
            invar['PARiPlante'][nump].append(PARaF)
            produce GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump,nsh,newage,rank,rankp,l,tt_omb,'sen',ordre)
        elif tt_omb> ParamP[nump]['ombF_Ttresh']:
            #print "ombre!"
            if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee 
                surf_elementaire = surF / float(len(ls_pts[0]))
                for i in range(len(ls_pts[0])):
                    vox = ls_vox[i]
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
            else:
                m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF 
            
            invar['PARiPlante'][nump].append(PARaF)
            produce GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump,nsh,newage,rank,rankp,l,tt_omb+STEPS,'sen',ordre)
        else:
            invar['PARaPlante'][nump].append(PARaF)
            invar['PARiPlante'][nump].append(PARaF)
            adTTomb = STEPS if PARif <= ParamP[nump]['ombF_Ltresh'] else 0
            
            if statut == 'exp':
                pot = sh.expansion(age+STEPS, ParamP[nump]['aF'], ParamP[nump]['delaiF']) - sh.expansion(age, ParamP[nump]['aF'], ParamP[nump]['delaiF'])
                dl = pot*ls_ftswStress['WaterTreshExpSurf'][nump]*ls_NNIStress['NTreshExpSurf'][nump]
                newsurF = sh.calc_surF(ParamP[nump], rank, rankp, ordre, l+dl)
                
                if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee 
                    surf_elementaire = newsurF / float(len(ls_pts[0]))
                    for i in range(len(ls_pts[0])):
                        vox = ls_vox[i]
                        m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
                else:
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += newsurF
                
                stat = 'mat'if pot<0.005 and age>ParamP[nump]['delaiF'] else 'exp'
                produce GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump,nsh,newage,rank,rankp,l+dl,tt_omb+adTTomb,stat,ordre)
            elif statut == 'mat':
                if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee 
                    surf_elementaire = surF / float(len(ls_pts[0]))
                    for i in range(len(ls_pts[0])):
                        vox = ls_vox[i]
                        m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
                else:
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF
                
                produce GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump,nsh,newage,rank,rankp,l,tt_omb+adTTomb,statut,ordre)


Stp(nump,azi,l, statut) > Pet(nump1, nsh, age, azi1, l1, statut1)GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,rank,rankp,l2,tt_omb,statut2,ordre):
    STEPS = invar['dTT'][nump]
    
    if ParamP[nump]['gotStip']== 1. and age < ParamP[nump]['spanMrt']:#presence stipules
        #strate = max(0, int(ceil((Z0+0.00001)/dz))-1)
        vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
        strate = vox[2] #starte z
        
        surF = sh.calc_surS(ParamP[nump], rank, rankp, ordre, l) #m2
        PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise
        I_I0 =  PARif/meteo_j['I0']
        classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.
        
        sVOX = m_lais[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]]
        if sVOX>0.:
            PARaF = res_abs_i[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] * surF/sVOX *3600.*24/1000000.
        else:
            PARaF = res_trans[vox[2]][vox[1]][vox[0]] * surF * 3600.*24/1000000.
        #print PARaF, PARaF_bis, sVOX#
        
        lsOrgans.append([TT,'Stp',nump,nsh2,rank,rankp,strate,surF,PARaF,statut,age2+STEPS,ordre,l,'NA',DOY,cutNB,'NA'])
        SurfprofilPlant[nump][strate] += surF #suppose mis dans meme strate que feuille
        I_I0profilLfPlant[nump][classI_I0] += surF
        invar['SurfPlante'][nump].append(surF)
        invar['PARiPlante'][nump].append(PARaF)
        invar['PARaPlante'][nump].append(PARaF)
        
        
        if statut == 'exp':
            pot = sh.expansion(age2+STEPS, ParamP[nump]['aS'], ParamP[nump]['delaiS']) - sh.expansion(age2, ParamP[nump]['aS'], ParamP[nump]['delaiS'])
            dl = pot*ls_ftswStress['WaterTreshExpSurf'][nump]*ls_NNIStress['NTreshExpSurf'][nump]
            newsurF = sh.calc_surS(ParamP[nump], rank, rankp, ordre, l+dl)
            m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += newsurF
            
            if pot<0.005 and age>ParamP[nump]['delaiS'] :
                produce Stp(nump,azi,l+dl, 'mat')
            else :
                produce Stp(nump,azi,l+dl, 'exp')
        else : #reste en 'mat'
            m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF
            produce Stp(nump,azi,l, 'mat')
    elif ParamP[nump]['gotStip']== 1. and age >= ParamP[nump]['spanMrt']: # stipule mort ou 'spanMrt' -> retire de la chaine et met ddans residus feuille
        surF = sh.calc_surS(ParamP[nump], rank, rankp, ordre, l)#m2      
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        mfeuilmorte = surF*10000/ParamP[nump]['SLAmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4][voxsol[2]][voxsol[1]][voxsol[0]] += mfeuilmorte
        produce *
    else: 
        produce *


Pet(nump,nsh,age, phyllotax, l, statut) > GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,rank,rankp,l2,tt_omb,statut2,ordre):
    global ls_ftswStress
    STEPS = invar['dTT'][nump]
    
    newage = age+STEPS
    lpet = sh.calc_Lpet(ParamP[nump], rank, rankp, ordre, l)
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise
    I_I0 =  PARif/meteo_j['I0']
    classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.
    I_I0profilPetPlant[nump][classI_I0] += lpet
    #photomorphogenese
    
    RFR=res_rfr[vox[2]][vox[1]][vox[0]]
    RFR_effect=(ParamP[nump]['photomorphRFR_pet'][0]*RFR)+ParamP[nump]['photomorphRFR_pet'][1]
    
    durjour = sh.DayLength (latitude,sh.DecliSun (DOY % 365))
    PAReff = PARif * 24./durjour #courbe de reponse au PAR calle sur moyenne sur photoperiode
    PAR_effect= sh.trilineaire(PAReff,ParamP[nump]['photomorphPAR_pet'][0],ParamP[nump]['photomorphPAR_pet'][1],ParamP[nump]['photomorphPAR_pet'][2],ParamP[nump]['photomorphPAR_pet'][3])
    photomorph=RFR_effect*PAR_effect#1.
    invar['phmgPet'][nump].append(photomorph)
    invar['phmgPet_m'][nump].append(photomorph)
    
    lsOrgans.append([TT,'Pet',nump,nsh,rank,rankp,'NA','NA','NA',statut,newage,ordre,l,lpet,DOY,cutNB,'NA'])#decalage de un step pour l avec age en exp ou mort
    
    if age> ParamP[nump]['spanMrt'] or nsh in invar['lsApexMort'][nump]:#mort du module
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        mpetmort = lpet*100/ParamP[nump]['SPLmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4][voxsol[2]][voxsol[1]][voxsol[0]] += mpetmort
        invar['dMSenTige'][nump] += mpetmort#g
        produce *
    
    elif statut == 'exp':
        pot = sh.expansion(newage, ParamP[nump]['aP'], ParamP[nump]['delaiP']) - sh.expansion(age, ParamP[nump]['aP'], ParamP[nump]['delaiP'])
        dl = pot * ls_ftswStress['WaterTreshExpSurf'][nump] *ls_NNIStress['NTreshExpSurf'][nump]* photomorph
        
        if pot<0.005 and age>ParamP[nump]['delaiP']:#passe en 'mature'
            produce Pet(nump,nsh,newage, phyllotax, l+dl, 'mat')
        else: #reste en 'exp'
            produce Pet(nump,nsh,newage, phyllotax, l+dl, statut)
    else:#reste en 'mat'
        produce Pet(nump,nsh,age+STEPS, phyllotax,l,statut)


GetPos(X0,Y0,Z0)In(nump,nsh,age,rank,rankp, l, statut,ordre):
    global ls_ftswStress, lsOrgans      
    STEPS = invar['dTT'][nump]
    
    newage = age+STEPS
    lent = sh.calc_Lent(ParamP[nump], rank, nsh, ordre, l)#cm
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise
    I_I0 =  PARif/meteo_j['I0']
    classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.    
    
    RFR=RFR=res_rfr[vox[2]][vox[1]][vox[0]]
    RFR_effect=(ParamP[nump]['photomorphRFR_int'][0]*RFR)+ParamP[nump]['photomorphRFR_int'][1]
    
    durjour = sh.DayLength (latitude,sh.DecliSun (DOY % 365))
    PAReff = PARif * 24./durjour #courbe de reponse au PAR calle sur moyenne sur photoperiode
    PAR_effect= sh.trilineaire(PAReff,ParamP[nump]['photomorphPAR_int'][0],ParamP[nump]['photomorphPAR_int'][1],ParamP[nump]['photomorphPAR_int'][2],ParamP[nump]['photomorphPAR_int'][3])
    photomorph=RFR_effect*PAR_effect #1.
    invar['phmgEntr'][nump].append(photomorph)
    invar['phmgEntr_m'][nump].append(photomorph)
    
    lsOrgans.append([TT,'In',nump,nsh,rank,rankp,'NA','NA','NA',statut,newage,ordre, l,lent,DOY,cutNB,'NA']) #decalage de un step pour l et age en exp!
    invar['NBphyto'][nump] += 1 #comptage du phytomere 
    
    if nsh in invar['lsApexMort'][nump]: #Meurt si tige meurt meurt
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        minmort = lent*100/ParamP[nump]['SNLmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4+1][voxsol[2]][voxsol[1]][voxsol[0]] += minmort
        invar['dMSenTige'][nump] += minmort
        produce *
    elif statut == 'exp':
        pot = sh.expansion(age+STEPS, ParamP[nump]['aE'], ParamP[nump]['delaiE']) - sh.expansion(age, ParamP[nump]['aE'], ParamP[nump]['delaiE'])
        dl = pot * ls_ftswStress['WaterTreshExpSurf'][nump] *ls_NNIStress['NTreshExpSurf'][nump]* photomorph
        
        if pot<0.005 and age>ParamP[nump]['delaiE']:#passe en 'mature'
            produce GetPos(X0,Y0,Z0)In(nump,nsh,newage,rank,rankp, l+dl, 'mat',ordre)
        else: #reste en 'exp'
            produce GetPos(X0,Y0,Z0)In(nump,nsh,newage,rank,rankp, l+dl, statut,ordre)
    else: #reste en 'mat'
        produce GetPos(X0,Y0,Z0)In(nump,nsh,age+STEPS,rank,rankp, l, statut,ordre)


D(nump,nsh, statut,age,posi,parent):
    STEPS = invar['dTT'][nump]
    invar['NBD1'][nump]+=1
    nbExp_Prev = outvar['NBBexp'][-1][0][nump+2]+1 #nb bourgeons type exp juste avant
    
    
    if parent in invar['lsApexMort'][nump]: #Meurt si parent meurt
        #invar['lsApexMort'][nump].remove(parent) #l'enleve pas de la liste car sinon pas visible pour autres organes
        invar['countShExp'][nump] -= 1
        produce *
    #elif nbExp_Prev<=ParamP[nump]['NBexp'] and invar['countShExp'][nump]< ParamP[nump]['nshoots']-1:#cree bourgeon si NBB exp pas atteint
    #    print 'vrai'
    #    outvar['NBBexp'][-1][0][nump+2] +=1
    #    invar['NBBexp'][nump] +=1
    #    newage = age%ParamP[nump]['phyllochron']+STEPS
    #    new_nrhiz = binomial(ParamP[nump]['DistLRhiz'][0], ParamP[nump]['DistLRhiz'][1])#2#0
    #    newazi = random.uniform(0.,360.)
    #    produce @M(posi[0],posi[1],posi[2])SetHead()/(newazi)&(90)B(nump, nsh, newage, posi, new_nrhiz,newazi, 0,'exp')
    elif not parent in invar['lsAPrev'][nump] :#and statut==0: #sort de dormance si tige parente coupee
        #newage = age%ParamP[nump]['phyllochron']+STEPS
        #produce D(nump,nsh,1,newage,posi,parent)
    #elif statut ==1:#pas d'apres produit un nouvel axe
        NIparent = max(invar_sc['sh']['MaxNI'][str(nump)+'_'+str(parent)])
        deltaBud = sh.MaturBud(ParamP[nump]['delaiMaturBud'], NIparent)
        
        #newage = age%ParamP[nump]['phyllochron']+STEPS
        newage = deltaBud*ParamP[nump]['phyllochron']# + STEPS  #+age%ParamP[nump]['phyllochron'] #rajoute pas le steps car compare a zero apres
        new_nrhiz = binomial(ParamP[nump]['DistLRhiz'][0], ParamP[nump]['DistLRhiz'][1])#2#0
        newazi = random.uniform(0.,360.)
        
        #print 'D', nsh, parent, NIparent, deltaBud, newage
        
        produce @M(posi[0],posi[1],posi[2])SetHead()/(newazi)&(90)B(nump, nsh, newage, posi, new_nrhiz,newazi, 0,'regular') #un bourgeon ave un nsh qui ne rajoute pas de nvelle tige
    else:
        produce D(nump,nsh, statut,age+STEPS,posi,parent)


D2(nump, nsh, age, rankp, phyllotax,shoottype):
    STEPS = invar['dTT'][nump]
    
    if nsh in invar['lsApexMort'][nump] or shoottype=="primary": #Meurt si tige porteuse meurt #disparait si il y a aussi un D avec lequel D2 fait "double emploi"
        produce *
    elif age <= ParamP[nump]['delai_deb']-ParamP[nump]['phyllochronII']:
        #print("agetropjeune",age)
        produce D2(nump,nsh,age+STEPS,rankp, phyllotax,shoottype)
    elif int(ParamP[nump]['ActiveBranch'])==True:
        init_age = age-(ParamP[nump]['delai_deb']-ParamP[nump]['phyllochronII'])
        #print("agedepasse",init_age, age)
        elv0 = 45
        if rankp%2==0:
            produce +(90-elv0)GetPos(0,0,0)A2(nump, nsh, 1, init_age, 0, 0, rankp, phyllotax+30)
        else:
            produce -(90-elv0)GetPos(0,0,0)A2(nump, nsh, 1, init_age, 0, 0, rankp, phyllotax+30)

RA(nump, nsh, age, rankp, agecum, moduloH):
    STEPSsol = invar['dTTsol'][nump]
    
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    
    # quelle prof max de sol si il y a un obstarac?
    if S.obstarac is None or type(S.obstarac != type(array([0.]))):
        prof_obst = prof_sol_max
    else:
        #dans quel voxl de sol est la plante
        vox = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        prof_obst =  -S.obstarac[vox[0], vox[1]]*100.
        #print 'sol depth', prof_sol_max, vox, S.obstarac[vox[0], vox[1]]#, na, [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], vox
    
    
    if moduloH>invar['RDepth'][nump]:
        invar['RDepth'][nump]=moduloH
    
    #ajout d'un cyclindre dans syst racinaire pour racine primaire/pivot
    ls_systrac[nump].append([carto[nump][0],carto[nump][1],0.,0.01,max(moduloH,0.01)])
    
    #ajout dans ls_organs
    lsOrgans.append([TT,'Piv',nump,nsh,rankp,0,'NA','NA','NA','NA',agecum+STEPSsol,1,0,moduloH,DOY,cutNB,'NA'])
    
    
    #calcul ratio QD instantane
    if(agecum<ParamP[nump]['DurGraine']):
        ratio=1.
    else:
        ratio = rt.get_QDCmoy(invar_sc['ax']['QDCRac'], idax) 
    
    #seuil pour emission d'un nouveau root segment
    tresh=ParamP[nump]['Relongation_duration0']/max(0.0001, ratio)
    #print moduloH, moduloH%dz_sol, prof_sol_max
    if age>tresh and moduloH%dz_sol==0. and moduloH<min([prof_sol_max, prof_obst]):
        #print moduloH, dz_sol, moduloH%dz_sol, int(moduloH/dz_sol)
        produce RLB(nump,nsh,0,rankp, int(moduloH/dz_sol))RS(nump,nsh, rankp,moduloH)RA(nump,nsh, age%tresh+STEPSsol, rankp, agecum+STEPSsol, moduloH+ParamP[nump]['LRS'])
    elif age>tresh and moduloH<min([prof_sol_max, prof_obst]):
        produce RS(nump, nsh, rankp, moduloH)RA(nump, nsh, age%tresh+STEPSsol, rankp, agecum+STEPSsol,moduloH+ParamP[nump]['LRS'])
    else:
        produce RA(nump,nsh, age+STEPSsol, rankp, agecum+STEPSsol,moduloH)


RLB(nump,nsh,age,rankp, Horiz):
    STEPSsol = invar['dTTsol'][nump]
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    
    #calcul ratio QD instantane
    ratio = rt.get_QDCmoy(invar_sc['ax']['QDCRac'], idax)
    
    tresh=ParamP[nump]['delai_RLAP']/max(0.0001, ratio)
    
    if age>tresh:
        produce [GetPos(0.,0.,0.)RLAP(nump,nsh,age%tresh+STEPSsol, rankp, 0.01, Horiz)]
    else:
        produce RLB(nump,nsh,age+STEPSsol,rankp, Horiz)


GetPos(X0,Y0,Z0)RLAP(nump,nsh,age,rankp,l, Horiz):
    STEPSsol = invar['dTTsol'][nump]
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    
    #calcul ratio QD instantane
    ratioC = rt.get_QDCmoy(invar_sc['ax']['QDCRac'], idax) 
    
    #stressHydrique
    stressH = sh.FTSW_resp(mean(S.ftsw_t[Horiz,:,:]), ParamP[nump]['WaterTreshElRoots'])
    
    #ajout pondere pour calcul de stress H racinaire global
    invar_sc['ax']['StressHRac'] = IOxls.add_dic({idax:stressH*l}, invar_sc['ax']['StressHRac'])
    invar_sc['ax']['PonderStressHRac'] = IOxls.add_dic({idax:l}, invar_sc['ax']['PonderStressHRac'])
    
    #print idax, stressH, invar_sc['ax']['StressHRac'][idax] / invar_sc['ax']['PonderStressHRac'][idax]
    
    dl = (STEPSsol/ParamP[nump]['Relongation_durationII'])*ratioC*stressH
    #print dl, invar_sc['ax']['QDCRac'], invar_sc['ax']['AgePiv']#invar_sc['ax']['OfrCRac']#ratioC, stressH
    # nbplantes, invar_sc['ax']['AgePiv'], invar_sc['plt']['PARaF'], invar_sc['ax']['PARaF']
    #RprospectProfil[nump][Horiz] = l+dl
    
    #calculation new enveloppe
    id = rt.idLong(l, ParamP[nump]['profilRoot'])#rpy.r.idLong(l, ParamP[nump]['profilRoot'])
    larg = ParamP[nump]['profilRoot']['y'][id]#['y'][id[0]]#['y'][id]
    long = min(max(dz_sol ,ParamP[nump]['profilRoot']['x'][id]), prof_sol_max+Z0)#['x'][id[0]]), prof_sol_max+Z0)#['x'][id]), prof_sol_max+Z0)
    ls_systrac[nump].append([X0,Y0,-Z0,larg,long])
    
    if age<=(ParamP[nump]['GDs1']+ParamP[nump]['GDs2'])/2:#durre expansion enveloppe secondaire determinee par Dmax et D2 -> devrait utiliser varD pour laterales les plus larges
        produce GetPos(X0,Y0,Z0)RLAP(nump,nsh,age+STEPSsol,rankp, l+dl, Horiz)
    else:
        produce GetPos(X0,Y0,Z0)RLAP(nump,nsh,age+STEPSsol,rankp, l, Horiz)
    #rq: croissance indeterminee! -> tient pas compte de GDs



[GetPos(X0,Y0,Z0)RB(nump,nsh,age,rankp,statut)]:
    global S
    STEPSsol = invar['dTTsol'][nump]
    
    Horiz=0
    if Z0 > ParamP[nump]['HeightTreshAdvRoots']: #supprime bud si au dessus d'une hauteur seuil
        produce *
    elif age>ParamP[nump]['delai_AdvRoots'] and statut==0:
        pb = random.uniform(0.,1.)
        if pb<ParamP[nump]['ProbaMaxAdvRoots'] :
            if mean(S.ftsw_t[Horiz,:,:]) > ParamP[nump]['WaterTreshAdvRoots']:
                produce [;(0)SetHead(0,0,-1, -1,0,0)RA(nump,nsh,-1,rankp,0,0)]
            else:
                produce [GetPos(X0,Y0,Z0)RB(nump,nsh,age+STEPSsol,rankp,1)] #statut
        else: #supprime bud si sous proba seuil
            produce *
    elif statut==1 :#en attente bloque par stress hydrique
        if age>ParamP[nump]['delai_AdvRoots']+ParamP[nump]['fenetre_AdvRoots']:
            produce *
        else:
            if mean(S.ftsw_t[Horiz,:,:]) > ParamP[nump]['WaterTreshAdvRoots']:
                produce [;(0)SetHead(0,0,-1, -1,0,0)RA(nump,nsh,-1,rankp,0,0)]
            else:
                produce [GetPos(X0,Y0,Z0)RB(nump,nsh,age+STEPSsol,rankp,statut)]
    else:#statut 0 en attente du delai de debourrement 'delai_AdvRoots'
        produce [GetPos(X0,Y0,Z0)RB(nump,nsh,age+STEPSsol,rankp,statut)]

[] --> * #pour nettoyer les bracket des D() morts


sol(sol_obj, nbcol):
    if nbcol>0:
        nproduce [solxy(sol_obj, nbcol-1)]sol(sol_obj, nbcol-1)
    else:
        produce *

attente(n):
    global S, discret_solXY
    if n>0:
        produce attente(n-1)
    else:
        produce pattern(0)sol(S, discret_solXY[1])


interpretation:
SHP(nump,azi, elv0,posi,nbp,par):
    if elv0 < ParamP[nump]['elvtresh'] and par>=meteo_j['I0']*ParamP[nump]['par_tresh']:#pour moduler incli0 par longueur/incli en plante isolee
        Lsh = ParamP[nump]['Len']*nbp
        Hsh = Lsh*sin(elv0*pi/180.)
        corr_elv = max(0,(ParamP[nump]['Lmaxeffet']-Hsh))/ParamP[nump]['Lmaxeffet'] 
    elif elv0 < 60 and par<meteo_j['I0']*ParamP[nump]['par_tresh']: #pour moduler incli competition forte/ a revoir au niveau de la loi de ditrib ou de elasticite
        corr_elv =1.#1.3
    else:
        corr_elv =1.
        
    produce &(-elv0*corr_elv)


In(nump,nsh,age,rank,rankp, l, statut,ordre):
    lent = sh.calc_Lent(ParamP[nump], rank, nsh, ordre, l)*100. #cm
    if ordre==2:
        color=2
    else:
        color=3
    if ordre==1 and nsh==0:
        color=2
    
    if visu_shoot==1:
        #produce ;(2)@Tp([0,0,1])Ts(lent*ParamP[nump]['elasticity'])F(lent,0.3)
        produce ;(color)@Tp([0,0,1])@Ts(min(1,lent*ParamP[nump]['elasticity']))F(lent,0.3)# modif lucas : min() car avait de drole de comportement sans ca a certaines valeurs
    else:
        produce ;(color)@Tp([0,0,1])@Ts(min(1,lent*ParamP[nump]['elasticity']))f(lent,0.3)# modif lucas : min() car avait de drole de comportement sans ca a certaines valeurs

A(nump,nsh,statut,age, duromb, rank, phyllotax):
    if visu_shoot==1:
        if statut ==1:
            produce ;(3)Sphere(0.4)
        else:
            produce ;(4)Sphere(0.4)

A2(nump, nsh, statut, age, duromb,rank, rankp, phyllotax):
    if visu_shoot==1:
        if statut ==1:
            produce ;(1)Sphere(0.3)
        else:
            produce ;(4)Sphere(0.3)


#D(nump,statut,posi) --> @M(posi[0],posi[1],posi[2])#;(1)Sphere(0.2)#les voit pas


Pet(nump, nsh, age, azi,l1, statut1) > GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,rank,rankp,l2,tt_omb,statut2,ordre):
    lpet = sh.calc_Lpet(ParamP[nump], rank, rankp, ordre, l1)*100.#cm
    IncPet = ParamP[nump]['IncPet']
    if visu_shoot==1:
        produce SetHead(0,0,1, 1,0,0)/(azi%360)Up(IncPet)_(0.1)F(lpet,0.1)SetHead(0,0,1, 1,0,0)/(azi%360-90)
        #produce SetHead(0,0,1, 1,0,0)/(azi%360)Up(IncPet);(2)F(0.00001,0.1)F(lpet,0.1)SetHead(0,0,1, 1,0,0)/(azi%360-90)  
    else:
        produce SetHead(0,0,1, 1,0,0)/(azi%360)Up(IncPet)_(0.1)f(lpet,0.1)SetHead(0,0,1, 1,0,0)/(azi%360-90)


Lf(nump, nsh, age, rank, rankp, l, tt_omb, statut,ordre):
    if visu_shoot==1:
        cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
        rk = rank+rankp if ordre==2 else rank
        rk = min(rk, len(ParamP[nump]['profilLeafI_l'])-1) #au cas ou profil pas assez long
        Long  = ParamP[nump]['profilLeafI_l'][rk]*l*cor_ordre
        Larg = ParamP[nump]['profilLeafI_larg'][rk]*l*cor_ordre
        nf = ParamP[nump]['profilLeafI_nfol'][rk]
        if statut == 'exp' or statut == 'mat':
            col=2#2
        elif statut == 'sen':
            col = 1
        
        if ordre ==2:
            col = 3#2
            
        #insere pour mixtures
        if int(ParamP[nump]['type'])==1:
            col=2
        else:
            col=6
        
        #geom = o3d.leg_leaf(Long, Larg, gamma=ParamP[nump]['gammaFeuil'])
        geom = o3d.leg_leaf_lucas(Long, Larg, gamma=ParamP[nump]['gammaFeuil'], nfol=nf, anginit=ParamP[nump]['IncPet'])
        #print o3d.leg_leaf_lucas(Long, Larg, gamma=ParamP[nump]['gammaFeuil'], nfol=nf, anginit=ParamP[nump]['IncPet'], geom=False)
        produce ;(col)@g(geom)


Stp(nump, azi,l, statut)> Pet(nump1, nsh, age, azi1, l1, statut1)GetPos(X0_,Y0_,Z0_)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,rank,rankp,l2,tt_omb,statut2,ordre):
    if visu_shoot==1:
        if ParamP[nump]['gotStip']== 1.:
            cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
            rk = rank+rankp if ordre==2 else rank
            rk = min(rk, len(ParamP[nump]['profilStipI_l'])-1) #au cas ou profil pas assez long
            Long = l*ParamP[nump]['profilStipI_l'][rk]*cor_ordre
            Larg = l*ParamP[nump]['profilStipI_larg'][rk]*cor_ordre
            stip = o3d.geomstip(Long, Larg,alpha=90,gamma=ParamP[nump]['gammaFeuil'])
            col = 5#0#2#
            produce SetHead(0,0,1, 1,0,0)/(azi%360-90);(col)@g(stip)
            #y a des implicites pour les angles


Coll(posi) --> @M(posi[0],posi[1],posi[2])[;(0)SetHead(0,0,-1, -1,0,0) #! contient ouverture de [ du systeme racinaire

RA(nump,nsh,age, rankp,agecum,moduloH): 
    if visu_root==1:
        produce ;(3)Sphere(0.4)

RS(nump, nsh, rankp, moduloH):
    #diampiv = max(0.1 ,invar['DiampivMax'][nump]*(1-moduloH/ParamP[nump]['ZPivot_min'])) 
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    diampiv = max(0.1 ,invar_sc['ax']['DiampivMax'][idax]*(1-moduloH/ParamP[nump]['ZPivot_min']))
    if visu_root==1:
        produce ;(1)_(diampiv)F(ParamP[nump]['LRS'])
    else:
        produce ;(1)_(diampiv)f(ParamP[nump]['LRS'])

RLB(nump,nsh,age,rankp, Horiz): 
    if visu_root==1:
        produce ;(0)Sphere(0.4)

RLAP(nump,nsh,age,rankp, l, Horiz): 
    id = rt.idLong(l, ParamP[nump]['profilRoot'])#rpy.r.idLong(l, ParamP[nump]['profilRoot'])
    #print id, l, ParamP[nump]['profilRoot']['y']
    larg = ParamP[nump]['profilRoot']['y'][id]#['y'][id[0]]#['y'][id]#
    long = max(dz_sol ,ParamP[nump]['profilRoot']['x'][id])#['x'][id[0]])#['x'][id])
    if visu_root==1:
        produce ;(0)_(larg)F(long)
        #produce ;(0)_(l)F(dz_sol)
    else:
        produce ;(0)_(larg)f(long)

solxy(sol_obj, idcol):
    if visu_sol == 1:
        global dz_sol, ncouches_sol, discret_solXY
        #print mean(sol_obj.HRp(), axis=1)[:,0]#mean(mean(sol_obj.HRp(), axis=0), axis=0)
        Nmin_xy = mean(sol_obj.m_NO3, axis=1)#mean(sol_obj.m_NO3+sol_obj.m_NH4)/(sol_obj.m_soil_vol*sol_obj.m_DA)*1000, axis=1)
        norm_Nmin_xy = Nmin_xy/Nmin_xy.max()
        norm_Nmin_xy = norm_Nmin_xy[:,idcol]
        
        ftsw_xy = mean(sol_obj.ftsw_t, axis=1)[:,idcol]
        nbcol = discret_solXY[1]
        larg_box = 30.
        
        #print norm_Nmin_xy #ftsw_xy
        for i in range(ncouches_sol):
            z = -i*dz_sol
            values = ftsw_xy#norm_Nmin_xy#   A changer pour voir variable de sortie souhaitee
            
            #ftsw = max(0., mean(sol_obj.ftsw_t[i,:,:]))
            ftsw = max(0, values[i])
            col = 16 + int(ceil((1-ftsw)/0.1))
            #nproduce ;(col)@M(-50,0,z-dz_sol)@g(Box(1,30,dz_sol))
            nproduce ;(col)@M(-50,float(idcol)*2*larg_box/float(nbcol),z-dz_sol)@g(Box(1,larg_box/float(nbcol),dz_sol))



sol(sol_obj, nbcol):
    if visu_sol == 1:
        #l'affiche au premier step pour bien definir champs de la camera
        global dz_sol, ncouches_sol
        #print mean(sol_obj.HRp(), axis=1)[:,0]#mean(mean(sol_obj.HRp(), axis=0), axis=0)
        for i in range(ncouches_sol):
            z = -i*dz_sol
            ftsw = max(0., mean(sol_obj.ftsw_t[i,:,:]))
            #ftsw = max(0, ftsw_xy[i])
            col = 16 + int(ceil((1-ftsw)/0.1))
            nproduce ;(col)@M(-53,0,z-dz_sol)@g(Box(1,30,dz_sol))
            #nproduce ;(col)@M(-50,float(idcol)*30./float(nbcol),z-dz_sol)@g(Box(1,30./float(nbcol),dz_sol))




#aer:
#    global res_abs_i, dxyz, Hmaxcouv, Lsol, largsol
#    if(getIterationNb()>2):
#        for ty in range(5,20):
#          for tx in range(5,20):
#            for i in range(50):
#              z = 50*dxyz[2]-(i*dxyz[2])
#              x = tx*(dxyz[0])
#              y= ty*(dxyz[1])
#              xx0=-(dxyz[0]*Lsol/2)+dxyz[0]/2
#              yy0=-(dxyz[1]*largsol/2)+dxyz[1]/2
#              ftsw = max(0., res_abs_i[0][i][tx][ty])
#              col = 18 - int(ceil((ftsw)/0.025))
#              nproduce ;(col)@M(yy0+y,xx0+x,z+dxyz[0])@g(Box(dxyz[1]/2,1,dxyz[2]))


pattern(0):
    if visu_solsurf == 1:
        produce ;(1)@M((pattern8[1][0]+pattern8[0][0])/2.,(pattern8[1][1]+pattern8[0][1])/2.,0)@g(Box((pattern8[1][0]-pattern8[0][0])/2.,(pattern8[1][1]-pattern8[0][1])/2.,0.1))


attente(n):
    if visu_sol == 1:
        produce ;(1)@M(-53,0,0)@g(Box(1,30,150)) #pour creer fenetre de taille correcte


endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_0 = pgl.Material("Color_0" , ambient = (221,221,221) , diffuse = 0.723982 , )
	Color_0.name = "Color_0"
	context.turtle.setMaterial(0,Color_0)
	Color_4 = pgl.Material("Color_4" , ambient = (10,14,241) , diffuse = 0.746888 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_16 = pgl.Material("Color_16" , ambient = (0,0,234) , diffuse = 0.641026 , transparency = 0.5 , )
	Color_16.name = "Color_16"
	context.turtle.setMaterial(16,Color_16)
	Color_17 = pgl.Material("Color_17" , ambient = (63,63,239) , diffuse = 0.573906 , transparency = 0.4825 , )
	Color_17.name = "Color_17"
	context.turtle.setMaterial(17,Color_17)
	Color_18 = pgl.Material("Color_18" , ambient = (127,127,244) , diffuse = 0.506787 , transparency = 0.465 , )
	Color_18.name = "Color_18"
	context.turtle.setMaterial(18,Color_18)
	Color_19 = pgl.Material("Color_19" , ambient = (191,191,249) , diffuse = 0.439668 , transparency = 0.4475 , )
	Color_19.name = "Color_19"
	context.turtle.setMaterial(19,Color_19)
	Color_20 = pgl.Material("Color_20" , ambient = (255,255,255) , diffuse = 0.372549 , transparency = 0.43 , )
	Color_20.name = "Color_20"
	context.turtle.setMaterial(20,Color_20)
	Color_21 = pgl.Material("Color_21" , ambient = (248,212,212) , diffuse = 0.433345 , transparency = 0.416667 , )
	Color_21.name = "Color_21"
	context.turtle.setMaterial(21,Color_21)
	Color_22 = pgl.Material("Color_22" , ambient = (242,170,170) , diffuse = 0.494142 , transparency = 0.403333 , )
	Color_22.name = "Color_22"
	context.turtle.setMaterial(22,Color_22)
	Color_23 = pgl.Material("Color_23" , ambient = (236,127,127) , diffuse = 0.554938 , transparency = 0.39 , )
	Color_23.name = "Color_23"
	context.turtle.setMaterial(23,Color_23)
	Color_24 = pgl.Material("Color_24" , ambient = (229,85,85) , diffuse = 0.615734 , transparency = 0.376667 , )
	Color_24.name = "Color_24"
	context.turtle.setMaterial(24,Color_24)
	Color_25 = pgl.Material("Color_25" , ambient = (223,42,42) , diffuse = 0.676531 , transparency = 0.363333 , )
	Color_25.name = "Color_25"
	context.turtle.setMaterial(25,Color_25)
	Color_26 = pgl.Material("Color_26" , ambient = (217,0,0) , diffuse = 0.737327 , transparency = 0.35 , )
	Color_26.name = "Color_26"
	context.turtle.setMaterial(26,Color_26)
